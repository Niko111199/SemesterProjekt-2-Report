<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="Style.css">
    <link rel="icon" type="image/x-icon" href="Images/Icon.png">
    <title>Royal GO</title>
</head>
<body>

    <div class="Reporter">
        <ul>
            <li><a href="index.html">ProjektBeskrivelse</a></li>
            <li><a href="ProjektReport.html">ProjektRepport</a></li>
            <li><a href="ProcessReport.html">ProcesReport</a></li>
            <li><a href="Dokumenter/Gruppekontrakt.pdf" target="_blank">Gruppekontrakt</a></li>
        </ul>
    </div>

    <div class="cover">
        <H1>Via University College</H1>

    <br>
    <br>
    <br>
    <br>

    <h1>Royal GO - ProcessReport</h1>

    <br>
    <br>
    <br>
    <br>
    <br>
    

    <h1>Nikolaj Bræmer Christen, 354322</h1>
    <h1>Patick Overgaard Blauert, 353829</h1>
    <h1>Peter Hougaard, 353296</h1>
    <h1>Victor Bruun Fassbender, 354361</h1>
    <br>
    <h1>Vejledere:</h1>
    <h1>Henrik Kronborg Pedersen</h1>
    <h1>Søren Klit Lambæk</h1>

    <br>
    <br>
    <br>

    <div class="char-counter" id="charCounter" style="font-weight: bold; font-size: 25px;">Antal Tegn: 0</div>
    <h1>SoftWareInginør XR</h1>
    <h1>2. Semester</h1>
    <h1>05-03-2025 til 31-5-2025</h1>
        
    </div>

    <div class="toc">
        <h3>Indholdsfortegnelse</h3>
        <ul>
            <li><a href="#Indledning">1. Indledning</a></li>
            <li><a href="#Gruppearbejde">2. Gruppearbejde</a></li>
            <li><a href="#Projektopstart">3. Projektopstart</a></li>
            <li><a href="#Projektudførelse">4. Projektudførelse</a></li>
            <li><a href="#refleksioner">5. Personlige refleksioner</a></li>
            <li><a href="#vejledning">6. Refleksioner over vejledning</a></li>
            <li><a href="#Konklusion">7. Konklusion</a></li>
            <li><a href="#referencer">8. Referencer</a></li>
        </ul>
    </div>

    <div class="header">
        <span>Royal Go - Projektbeskrivelse</span>
        <img src="Images/VIA.png" alt="Logo">
        <hr>
    </div>

    <div class="content" id="content">
        <h2 id="Indledning">1. Indledning</h2>
        <p>
            <p>
                Dette semester har vi arbejdet med et projekt, der adresserer en stigende samfundsudfordring: den dalende fysiske aktivitet blandt især unge. 
                Med udgangspunkt i initiativet Bevæg dig for livet og eventet Royal Run, har vi valgt at undersøge og designe en digital løsning, der kombinerer fysisk aktivitet og digital interaktion – en tilgang vi anser som særlig relevant i en tid, hvor unge i stigende grad engagerer sig i verden gennem deres mobiltelefoner.
            </p>

            <p>
                Projektets mål har været at udvikle Royal GO, en mobilapplikation baseret på augmented reality (AR), der skal anvendes under Royal Run 2025 i Viborg. 
                Appen er rettet mod tilskuere og deltagere, som ikke nødvendigvis løber, men stadig ønsker at være aktive og engagere sig i begivenheden. 
                Ved at integrere elementer fra spil som Pokémon GO – såsom GPS-baserede aktiviteter, kosmetiske og belønninger forsøger Royal GO at motivere til bevægelse gennem leg og digitale incitamenter.
            </p>

            <p>
                Brugeren af Royal GO kan bevæge sig rundt i Viborg og finde virtuelle kronjuveler og en kongekrone, som genereres på forskellige steder i bybilledet. 
                Disse objekter udløser minispil og belønninger i form af in-game valuta, der kan bruges til at købe kosmetiske AR-effekter såsom face filters, som kan deles på sociale medier. 
                Formålet er at øge engagement og fysisk bevægelse gennem gamification og sociale elementer.
            </p>

            <p>
                Projektet blev gennemført i en SCRUM-baseret ramme, hvor arbejdet blev opdelt i sprintforløb med faste stand-up møder. 
                Denne struktur gav os mulighed for at følge fremdrift, tilpasse løbende og sikre en høj grad af gruppemedlemmernes involvering. 
                Projektets udvikling og samarbejdsproces blev dokumenteret gennem sprint-backlogs og logbøger, som samlet gav et overblik over forløbet. 
                Versionsstyring og samarbejde blev håndteret via GitHub, hvor vi benyttede branches og en validate branch for at sikre en struktureret og dokumenteret udviklingsproces.
            </p>

            <p>
                Vi har arbejdet med projektet i et problembaseret læringsmiljø (PBL), som har stillet krav til både faglig fordybelse og evnen til at samarbejde professionelt i en gruppe. 
                Vores tilgang og metoder har løbende udviklet sig i takt med projektets fremskridt, og gennem dette arbejde har vi opnået værdifuld erfaring med både teknisk udvikling, samarbejdsdynamikker og refleksion over egen læring.
            </p>
        </p>
        <div class="SideNummer"></div>
        
        <h2 id="Gruppearbejde">2. Gruppearbejde</h2>
        <p>
          <p>
              I projektet arbejdede vi tæt sammen i en gruppe bestående af 4. Peter, Victor, Nikolaj, Patrick, hvor vi hver især bidrog med forskellige kompetencer og faglige styrker. 
              Gruppen bestod af medlemmer med forskellige tekniske baggrunde, hvilket gav anledning til en dynamisk samarbejdsform, hvor opgaver og ansvarsområder blev fordelt i forhold til individuelle kompetencer og interesser.
          </p>

          <p>
              Eventuelle konflikter blev løst konstruktivt gennem åben dialog og respekt for hinandens perspektiver. 
              Vi oplevede generelt en høj grad af engagement, og der var ikke tydelige tilfælde af social loafing. 
              Vi holdt regelmæssige statusmøder til at koordinere kode og sikre fælles fremdrift.
          </p>

          <h3>Patrick</h3>
          <p>
              Mit primære bidrag lå inden for design og teknisk implementering af brugergrænsefladen samt funktionalitet i simulatoren Royal-Go. 
              Jeg var ansvarlig for udviklingen af mobilapplikationens UI, hvor jeg designede startmenuen og implementerede navigation mellem funktionerne Skattejagt, Skattekammer og Butik i Unity ved hjælp af C#. 
              Derudover skabte jeg en visuel identitet for applikationen, herunder logo-design og valg af farvepalette, med fokus på at skabe en sammenhængende og appellerende brugeroplevelse.
          </p>

          <p>
              I samarbejdet arbejdede jeg desuden på udviklingen af butiksscenariet, hvor jeg udviklede et konfigurerbart shop-system, designet til mobilvisning, og integrerede det med spillets valuta og AR-komponenter. 
              Jeg arbejdede iterativt og tilpassede løsningen undervejs, hvilket førte til vigtige læringer om systemintegration og runtime-datahåndtering i Unity.
          </p>

          <p>
              For at styrke brugeroplevelsen og den langsigtede spilprogression implementerede jeg et point-system med principper fra SOLID-arkitektur. 
              Systemet blev koblet til et leaderboard, hvor spillerens score vises og sammenlignes automatisk. 
              Jeg stod for integrationen af API-baseret highscore-visning samt tilpasning af UI til det samlede design.
          </p>

          <p>
              Jeg påtog mig rollerne som "Implementer", hvor jeg fokuserede på at omdanne ideer til funktionelle løsninger og bidrog med teknisk viden inden for UI og spiludvikling i Unity.
          </p>

          <h3>Victor</h3>

          <p>
              Jeg har primært i gruppearbejdet stået for bearbejdning og opbevarelse af gps og kompas-data. Meget af min tid har været brugt på at opstille arkitekturen for spillets databehandlingssystem. 
              Dette navigationssystem er designet ud fra at lade andre dele af spillets funktioner, såsom instantiering af objekter på punkter, nemt tilgå et behandlet og letlæseligt datasæt. 
          </p>

          <p>
              Jeg har desuden været ansvarlig for et disse systemer, altså visualiseringen af spillerens nuværende retning samt retningen af det næste punkt spilleren skal bevæge sig mod.
              Blandt dette system er også logikken for at fjerne punkter ved spillerens ankomst og udregne hvilket næste punkt er tættest på.
          </p>

          <p>
              Til sidst har jeg sammen med Peter lavet implementationstests af diverse systemer i arkitekturen. Her har jeg været ansvarlig for at teste det visuelle system af spiller- og lokationsretninger.
          </p>

        </p>
        <div class="SideNummer"></div>
        
        <h2 id="Projektopstart">3. Projektopstart</h2>
        <p>
            <p>
                Det i rød er, hvad der stod, frøer, den i sort er noget, jeg har lavet, men jeg ved ikke, om den er god nok (Patrick)
            </p>
            <h3 style="color: red;">Projekt indledene Opstart</h3>
            
            <p style="color:red">
                til at starte projekt, begyndte vi at kigge på userstorys, til at danne os et overblik
                over hvad vi vidste vores projekt skulle havde på det opstartende tidspunkt
            </p>

            <h3 style="color: red;">Projekt udførende Opstart</h3>
            <p style="color: red;">
                projektet opstars fase blev indledt med valget om at burge Unity 6.36f1,
                da dette var den nyeste stabile version er unity på det gældene tispunkt
            </p>

            <p>
              Projektets opstartsfase blev indledt med en fælles ideudvikling og diskussion af det overordnede problemfelt: fysisk inaktivitet blandt børn og unge, samt hvordan augmented reality (AR) kan anvendes til at fremme bevægelse i en moderne digital kontekst. 
              Gennem research og indledende drøftelser blev det besluttet at tage udgangspunkt i Royal Run som kontekst og udvikle en AR-oplevelse for tilskuere, hvilket skulle skabe en aktiv og engagerende oplevelse – også for dem, som ikke selv deltager i løbet.
            </p>

            <p>
              For at skabe overblik over projektets omfang og brugernes behov, arbejdede vi med user stories. 
              Dette gav os en struktureret tilgang til at identificere nøglefunktioner i appen, og det dannede grundlag for en mere præcis kravspecifikation. 
              Brugen af user stories i opstartsfasen hjalp os med at fokusere på brugercentreret design og sikrede, at vi fra start havde en klar forståelse af, hvordan applikationen skulle anvendes i praksis.
            </p>

            <p>
              Et vigtigt teknisk valg i opstartsfasen var beslutningen om at anvende Unity version 6.3.6f1 som udviklingsplatform. 
              Dette valg blev truffet, da det på daværende tidspunkt var den mest stabile og opdaterede version med understøttelse af AR-funktioner, der var nødvendige for appens funktionalitet. 
              Valget af platform blev støttet af tidligere erfaringer i gruppen og tilgængelig dokumentation, som gjorde det muligt at komme hurtigt i gang med prototyper og funktionelle tests.
            </p>

            <p>
                Sideløbende med de tekniske beslutninger udarbejdede vi en overordnet tidsplan, hvor projektet blev opdelt i sprint-forløb med milepæle og opfølgningspunkter. 
                Denne planlægning dannede grundlaget for vores SCRUM-baserede tilgang og hjalp os med at strukturere og styre projektets fremdrift fra starten.
            </p>
        </p>
        <div class="SideNummer"></div>
        
        <h2 id="Projektudførelse">4. Projektudførelse</h2>
        <p>
            <h3>Tilgåning af GPS Lokation</h3>

         <div class="container">
            <img src="Images/anmodomtilladelse.jpg" alt="anmodning om tilladelse" class="image">
                <p>
                  Da applikationen gør brug af GPS-lokationer ved at tilgå GPS-signaler fra brugerens enhed,
                  er det essentielt, at denne funktion håndteres i overensstemmelse med gældende lovgivning,
                  herunder persondataforordningen (GDPR). I henhold til artikel 6, stk. 1 i GDPR,
                  kræves et gyldigt retsgrundlag for behandling af personoplysninger, herunder lokaliseringsdata.
                  For at sikre, at behandlingen sker lovligt, tages der udgangspunkt i Digitaliseringsstyrelsens "Huskeregler for app-udbydere",
                  hvor det blandt andet anbefales at være gennemsigtig omkring anvendelsen af GPS samt at indhente eksplicit
                  samtykke ved opstart af applikationen.
                <br><br>
                  Implementeringen sker ved, at der i AndroidManifest-filen angives,
                  at tilladelse til adgang til lokaliseringsdata er nødvendig for,
                  at applikationen kan fungere. Derudover anvendes scriptet AccessLocationPermission,
                  som først kontrollerer, om brugeren overhovedet har givet tilladelse til,
                  at applikationer må benytte GPS-signaler. Såfremt denne tilladelse foreligger,
                  anmoder applikationen direkte brugeren om adgang til GPS-data for den specifikke app.
                  Først når begge tilladelser er givet, aktiveres GPS-sporingen ved hjælp af funktionen Input.location.Start().
                <br><br>
                  Af hensyn til dataminimering og for at sikre, at brugerens lokation ikke spores unødigt,
                  anvendes den indbyggede metode OnApplicationQuit(), hvor Input.location.Stop() kaldes.
                  Herved sikres det, at sporing udelukkende finder sted under aktiv brug af applikationen,
                  hvilket er i overensstemmelse med GDPR's principper om proportionalitet og dataminimering.
                </p>
            </div>
            <br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint">
            <div class="SideNummer"></div>

            <div class="page-break">
                <br class="onlyonprint"><br class="onlyonprint">
                <h3>Brug af GPS signal</h3>
            I den første iteration af applikationen skal systemet kunne få adgang til oplysninger om brugerens placering og sammenligne,
            om brugeren befinder sig på samme sted som en given position.
            For at opnå adgang til brugerens latitude og longitude kan metoderne
            input.location.lastData.latitude og input.location.lastData.longitude anvendes,
            når funktionen input.location.start() aktiveres. Dette muliggør,
            at systemet med hver opdatering kan registrere brugerens aktuelle koordinater (latitude og longitude).
            Derudover bør der implementeres et system til position sammenligning,
            idet målet er at udvikle et succesfuldt og langtidsholdbart software.
            For at sikre, at systemet er i overensstemmelse med SOLID-principperne,
            vil Haversine-formlen blive anvendt. Denne formel beregner afstanden mellem
            to punkter på en globus baseret på forskellene i latitude og longitude,
            hvilket sikrer mere præcise resultater, især over større afstande.
            </div>
            <br>
            Anvendelsen af Haversine-formlen vil yderligere muliggøre en fremtidig udvidelse
            af systemet til at dække større geografiske områder, hvis dette skulle blive nødvendigt.
            Når afstanden er beregnet ved hjælp af Haversine-formlen,
            kan den sammenlignes med en forudbestemt maksimal afstand, som systemet accepterer.
            Denne fremgangsmåde kan nemt udvides til at inkludere funktionalitet,
            der muliggør instantiationen af objekter på specifikke positioner.

            <h3>Navigationssystem</h3>

            <p>
              Navigationssystemet er designet ved hjælp af Facade-mønsteret, til at samle de mange unikke subklasser der er nødvendige.
              Det betyder at klassen NavigationsSystem benytter facaden til at klasserne KompasSystem, GPSSystem, DirectionCheck og PositionCheck,
              men at alt relevant data nemt og simpelt kan tilgås.  
            </p>

            <p>
              For at undgå en opadgående afhængighed benyttes Observer-mønstret til at sprede klassen NavigationSystemData til alle lyttere.
              Dennes publisher bruger en timer til at refreshe NavigationsSystemet, og dermed producere NavigationSystemData,
              som indeholder alt relevant data fra NavigationsSystem. 
            </p>

            <p>
              Eftersom navigationssystemet er meget vigtig for kernen af spillets koncept, skal der være ekstra opmærksomhed på ikke at skabe en "Gudeklasse".
              En måde hvorpå der forsøges at styrre dette på er ved ikke at have noget konkret udregning i NavigationSystem, blot samling af data fra flere steder. 
            </p>

            <p>
              For at simplificere outputtet fra forskellige klasser har de oftest fået en separat klasse der håndterer deres inputs.
              Fx GetGPSData fra GPSSystem retunere klassen GPSData, der er en klasse der indeholder horisontal præcision, længde – og breddegrader. 
              Der blev diskuteret hvor vidt det var bedre at kalde de individuelle funktioner hver for sig, over at oprette en helt ny klasse for at have dataen, 
              da det virkede lidt som at ”hælde fra en spand, til en anden”. Den endelige beslutning blev truffet da der blev enighed om at det stemte mest overens med
              single responsibility at have en enkelt public funktion der retunerede et sæt data. 
            </p>

            <p>
              I diskussionerne før facade mønstret blev endeligt besluttet blev der udforsket brugen af et decorator mønster.
              De ligner meget hinanden ved at bruge aggregation, i stedet for nedarvning, og de har begge adgang til mange classer. 
              På samme måde kan begge mønstre håndtere mange unikke retur typer og forskellige kald af funktoner. 
              Den endelige beslutning blev truffet ud fra at et decorator mønster er mere egnet til at udvidde en funktion i runtime, noget som projektet ikke havde behov for,
              da facaden starter med alle de klasser den har brug for. Derudover er det også tiltænkt at der kun er en enkelt NavigationSystem aktiveret i scenen ad gangen, 
              så hele nedarvnings princippet decorator mønstret facilitere er ikke nødvendigt.  
            </p>

            <h3>Indsamling af lokations- og kompasinformation</h3>
            
            <p>
              For at imødekomme principperne bag Single Responsibility, som er en del af SOLID-arkitekturen,
              er indsamlingen og den efterfølgende behandling af lokations- og kompasdata adskilt i separate klasser.
              Denne opdeling muliggører en mere effektiv anvendelse af Unitys indbyggede "MonoBehaviour"-package,
              idet databehandling og tilhørende beregninger kan håndteres uden for MonoBehaviour.
              Dette bidrager til en reduceret belastning af brugerens enhed og sikrer en mere ressourceeffektiv drift.
            </p>

            <h3>Databehandling uden for MonoBehaviour</h3>

            <h4>Anvendelse af Haversine-formlen til afstandsberegning</h4>

            <p>
              I forbindelse med betinget instansiering af kongekroner skal der verificeres, om spilleren befinder sig inden for en given radius af et referencepunkt.
              Denne afstandsberegning udføres ved hjælp af Haversine-formlen og er implementeret uden for MonoBehaviour i klassen "PositionCheck".
              Klassen tilbyder en offentlig metode, som returnerer en bool værdi afhængigt af, om spillerens position og
              objektets position overholder den givne radius.
            </p>

            <h4>Beregning af retning ved hjælp af bearing-formlen</h4>

            <h4></h4>
            <p>
              Udover afstanden skal også spillerens orientering verificeres for at muliggøre instansiering af kongekroner.
              Dette gøres ved anvendelse af bearing-formlen, som beregner vinklen mellem to punkter på en sfærisk overflade. 
              Implementeringen foretages i klassen "DirectionCheck", som er adskilt fra MonoBehaviour.
              Klassen indeholder en metode, der returnerer en bool afhængigt af,
              om vinklen mellem spillerens og objektets position befinder sig inden for en defineret grænseværdi for acceptabel retning.
            </p>

            <h3>opstart af augmented reality (kronjuveler)</h3>

            <div class="container">
                <img src="Images/DevArt.jpg" alt="DevArt" class="image">
              
                <p>
                  Efter at have etableret de fundamentale elementer til opbygningen af vores GPS-baserede system,
                  blev næste skridt at implementere en basal form for augmented reality (AR).
                  I denne forbindelse blev udviklingen af de tilfældigt genererede “kronjuveler” påbegyndt.
                  Disse objekter er placeret i nærheden af spilleren med det formål
                  at gøre dem let tilgængelige uden afhængighed af præcise GPS-koordinater.
                </p>
                <br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint">
                <div class="SideNummer"></div>
              
                <p>
                    <br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint">
                  For at opnå dette blev der udviklet et system baseret på plane detection.
                  Systemet anvender en raycasting-teknik, hvor der med faste tidsintervaller -
                  defineret mellem to inputværdier i sekunder  udsendes en ray fra telefonens kamera.
                  Denne ray fortsætter, indtil den registrerer et plane med en passende størrelse,
                  hvorefter et præfabrikeret objekt (prefab) instansieres på den fundne position.
                  På sigt planlægges dette system optimeret ved brug af objekt-pooling,
                  hvor objekter genbruges frem for at blive destrueret og oprettet på ny.
                  Det nuværende system instansierer dog stadig objekterne dynamisk i nærheden af spilleren.
                </p>
            
                <img src="Images/factoryPrefab.jpg" alt="DevArt" class="image">

                <p>
                  Instantieringen bliver gjordt ved brug af factory mønsteret der i hele projektet gør grundlag for instantiering af elementer i AR verdenen.
                  Dette er også med til at gøre det nemt og hurtigt senere i processen at udvide systemets funktionalitet med henblik på instantiering af andre elementer, for eksempel Skatteeventet.
                  Alle scripts som forholder sig til dette factory pattern bliver dernæst gæmt i en prefab som gør det muligt at ændre diverse variable, såsom typen af element som instantieres.
                </p>

                <p>
                  Ansvarligt for alt hvad der instantieres i scenen er "World Spawn Controlleren". Den fungerer i basis som en presenter for 3D-scenen.
                  Scriptet er i sig selv ikke synderligt komplekst men afhænger derimod af observer mønstre fra resten af modellen til at afgøre opdateringen af AR-verdenen. 
                  Scripts såsom "Juvel Controller", som holder styr på instantieringen af juveler, startes af World Spawn Controlleren.
                </p>

                <p>
                  "World Element Spawner" er ansvarlig for at finde det rigtige tid og sted at spawne et element ind i verdenen. 
                  I AR-verdenen er der behov for en reference / flade at instantiere noget på, i forbindelse med dette er der to vigtige ting at huske: For det første skal der være et sted at spawne, 
                  og for det andet, hvis der ikke er, skal spillet forsøge at spawne når der engang bliver et sted. Det er denne logik som World Element Spawneren står for, igennem funktionen
                  SpawnObjectInArWorld().
                </p>

                <img src="Images/FactoryDiagram.jpg" alt="DevArt" class="image">

                <p>
                  Efter implementeringen af denne funktionalitet var næste skridt at definere interaktionen mellem spilleren og kronjuvelerne.
                  Dette blev realiseret ved, at systemet registrerer spillerens tryk på skærmen og udsender en ray fra dette punkt.
                  Hvis ray'en rammer et objekt, der har det korrekte tag (dvs. identificeres som en “kronjuvel”),
                  aktiveres en funktion, der tilføjer en vis mængde guld til spillerens konto.
                  Objektet destrueres derefter (eller senere i udviklingen returneres til objekt-poolen).
                </p>
              
                <p>
                  Implementationen er gjordt gennem interfacet "IPressHandeler" som har funktionen OnPressed() som parameter i ARPressDetectoren, der nedarver fra MonoBehaviour og som derfor skal eksistere på et GameObject.
                  Ved instantiering af juvelen tilføjer JuvelProdukt, ARPressDetectoren til GameObjectet som det befinder sig på. 
                </p>

                <img src="Images/juvelprodukt.jpg" alt="DevArt" class="image">

                <p>
                  I forlængelse heraf blev der også implementeret et simpelt valutasystem,
                  som forbereder spillet på en fremtidig økonomifunktion. Systemet anvender Singleton Design Pattern for at sikre,
                  at den samme instans af valuta - kaldet “guld” - anvendes på tværs af alle scener og spilsituationer.
                  Da guld blot repræsenteres af en integer-værdi, gemmes denne ved hjælp af PlayerPrefs, hvilket sikrer,
                  at spillerens valuta bevares på tværs af spilsessioner - også efter at applikationen er lukket.
                  Singletonen tilgås fra JuvelProdukt ved hjælp af interfacet "IGoldManager".
                </p>
              
                <p>
                  Samlet set danner disse systemer et grundlag for både spillets AR-elementer og økonomiske mekanismer,
                  og de planlægges løbende optimeret med hensyn til ydeevne og brugervenlighed.
                </p>

                <h3>Lokationssporing og Spilområde</h3>

               <p>
                I denne nyupstartede iteration af systemet introduceres muligheden for sporing af specifikke positioner.
                Dette realiseres gennem en ny objektstruktur kaldet Location. Et Location-objekt indeholder tre variabler:
                en string, der repræsenterer navnet på positionen, samt to floats,
                som angiver henholdsvis breddegrad (latitude) og længdegrad (longitude).
                På baggrund heraf oprettes en liste, Locations, der samler flere Location-objekter og
                danner grundlag for videre funktionalitet, såsom søgning efter specifikke positioner.
                </p>
                
                <p>
                Yderligere introduceres konceptet om et "spilområde" (game area),
                hvilket definerer det geografiske område, inden for hvilket spillet skal foregå.
                Hvis en spiller bevæger sig uden for dette område, modtager vedkommende en besked, der informerer om,
                at han eller hun er uden for det tilladte spilleområde.
                For at bestemme spilområdets centrum anvendes listen af Locations.
                Systemet itererer gennem samtlige Location-objekter og beregner gennemsnittet
                af deres latitude- og longitude-koordinater. Resultatet bliver et centralt punkt,
                som repræsenterer midten af spilområdet.
                Ved hjælp af dette punkt kan systemet foretage en afstandsberegning mellem spilleren og centrum.
                Hvis afstanden er mindre end en foruddefineret radius,
                betragtes spilleren som værende inden for spilområdet;
                overskrides denne radius, anses spilleren for at have forladt området, og vil derved bliver
                informeret vedrørrende dette.
                </p>
                
                <h3>Bestemmelse af næste lokation</h3>
                <p>
                Når spilleren når den tilsigtede lokation og kongekronen initisaliseres, er det nødvendigt for systemet at skifte målet for spilleren til et nyt.
                Både for at undgå yderligere end 1 initialisering af kronen men også for at spilleren kan udforske alle punkter på listen. 
                Til dette er der implementeret en funktion i navigationssystemet kaldet "RemoveAndSetNewTarget()". 
                Her slettes først det nuværende "target" fra listen over placeringer før det nye bliver valgt.
                Funktionen udnytter den førnævnte klasse "positionCheck" som bruger Haversine-formlen til at give en afstand mellem punkter. 
                Med dette bruges en for-løkke til at køre i gennem alle punkter i listen over placeringer og finder den mindste afstand fra spillerens nuværende position.
                </p>
                
                
               <h3>Visualiering af spiller- og lokationsretninger</h3>

               <img src="Images/direction.png" alt="DevArt" class="image">
                <p>
                  For at kunne indikere en retning for spillerne at gå, 
                  kan en blanding af det nuværende mål og dets position, spillerens enheds kompas-retning og retningen til målet fra spillerens position bruges.
                  Alt informationen kan tilgås ved hjælp af event systemet som trækker data fra navigationssystemet. I en UIPresenter kaldet "DirectionPresenter"
                  opdateres to UI elementer med rotationsværdierne for spillerens orientation og retningen til næste mål. Pilen indikerer spillerens retning mens den røde indikator viser retningen til målet. 
                </p>
                
                <br><br><br>
                
                <h3>Logo-design</h3>
                
                <img src="Images/Logo2.png" alt="DevArt" class="image">
                <p>
                  Projektet omfattede desuden design af applikationens visuelle identitet gennem udviklingen af et logo. 
                  Logoet blev udformet med en kongekrone placeret over navnet Royal-Go, sat i en serif-skrifttype for at understøtte et klassisk og eksklusivt udtryk. 
                  Farvevalget blev foretaget med henblik på at forstærke appens tematiske fokus på luksus og eventyr. Følgende farver blev anvendt: guld (#FFD700), kongeblå (#4169E1) og baggrundsblå (#3E7ACB).
                </p>

                <p>
                  Sammenfattende blev der lagt vægt på at sikre sammenhæng mellem æstetik, funktionalitet og tematik, således at designvalg og tekniske løsninger understøttede applikationens overordnede formål og brugervenlighed.
                </p>

                <h3>Simulator (UI):</h3>

                <p>
                  Udviklingen af mobilapplikationen Royal-Go UI blev gennemført med fokus på design, brugergrænseflade og visuel identitet. 
                  I udviklingsfasen blev der udarbejdet en funktionel og intuitiv brugergrænseflade målrettet mobile enheder. 
                  Startmenuen blev designet til at give adgang til fem centrale funktioner: Skattejagt, Skattekammer, Submit Score, Leaderboard og Butik. 
                  Navigation mellem disse scener blev realiseret via et Scripts ” MainSceneChanger” i Unity, der kontrollerer sceneovergange baseret på brugerens input.
                </p>

                <img src="Images/TheUI.png" alt="DevArt" class="image" style="width: 300px; height: auto;">

                <p>
                    Et simpelt og genkendeligt design blev anvendt med tydelige knapper, grønne farveindikatorer for interaktive elementer og ikon baserede navigationssymboler, hvilket understøtter brugervenlighed på mobile enheder. 
                    Et indkøbskurvsikon blev i starten tilføjet som en visuel og funktionel knap til butiksscenen for at styrke brugerens mentale model af appens funktioner. 
                    Selve funktionaliteten blev bibeholdt, men det grafiske ikon blev ikke videreført i det endelige produkt, da det ikke passede ind i den visuelle helhed og appens øvrige designstil. UI’et anvender fortsat en vertikal struktur med letgenkendelige knapper og tekst, der guider spilleren gennem handlinger som køb, scoreindsendelse og visning af highscore.
                </p>

                <p>
                    Butiksscenen (vist i det femte skærmbillede) er designet med et simpelt og pædagogisk layout, hvor hvert kosmetisk item (f.eks. hat, maske, ansigt) vises med billede, pris og en “Køb”-knap. 
                    Guldmængden vises øverst i interfacet, hvilket giver brugeren konstant feedback på deres valuta. Scroll View, Vertical Layout Group og Content Size Fitter blev anvendt til dynamisk tilpasning af butiksindholdet, så det fungerer hensigtsmæssigt på skærme med forskellige opløsninger.
                </p>

                <p>
                    I Leaderboard-delen vises spillernes navne og scores med brug af TextMeshPro-komponenter og en dynamisk opdatering via en ekstern API. Submit Score-scenen er blevet tilpasset, så spillerens score automatisk hentes og vises uden manuel indtastning, hvilket forbedrer både dataintegritet og brugeroplevelse.
                </p>

                <p>
                    Der blev også integreret en Debug-knap i Startmenuen. Denne knap gjorde det muligt at teste funktionalitet hurtigt under udviklingsfasen og var et effektivt redskab til fejlfinding og validering af funktioner i realtid.
                </p>

                <p>
                    Til den tekniske implementering blev C# anvendt. For at muliggøre hurtig prototypeudvikling blev navigation og funktionalitet hardkodet, velvidende at denne metode er mindre skalerbar i større produktionsmiljøer, men egnet til en effektiv tidlig version. 
                    Denne tilgang gjorde det muligt hurtigt at afprøve og evaluere interaktioner og flow mellem UI-komponenter.
                </p>

                <p>
                    Brugergrænsefladen er udformet med enkle former og farver for at sikre visuel klarhed, især på mindre skærme. De anvendte designprincipper – som konsistens, visuel feedback, og minimal kognitiv belastning – understøtter en brugervenlig og funktionel oplevelse, hvilket har været centralt i designstrategien for Royal-Go.
                </p>

                <h3>Brugergrænseflade (UI) </h3>
                <p>
                  Brugergrænsefladen er designet ved hjælp af Model-View-Presenter (MVP) mønsteret. 
                  Her tænkes der på view delen som klasserne fra Unitys UnityEngine.UI namespace, hvilket er hvad der bruges til at designe udseenet til i Unitys builder. 
                  Presenteren bliver derfor primært vedhæftet det GameObject som indeholder det UI view den skal arbejde med. 
                </p>

                <p>
                  Den primære kontakt til presenteren fra modellen vil være ved gennem events, for at få så løs en kobling til modellen som muligt. 
                </p>
                
                <h3>Udvikling af ButikScene</h3>

                <p>
                    Under udvikling af en shop-funktion i Unity, hvor spilleren kan købe kosmetiske genstande for en opsamlet valuta (guld). 
                    Udviklingsprocessen har bestået af en iterativ tilgang, hvor funktionalitet gradvist blev udvidet og testet i sammenhæng med brugergrænseflade og gameplay-integration.
                </p>

                <p>
                    Projektet blev startet med et færdigt "gold script", der håndterede spillerens valuta, inklusive lagring og visning af guld. Dette script dannede fundamentet for hele shop-systemet. 
                    Dernæst blev et ShopManager-script udviklet med målet om at undgå hårdkodning og i stedet lade shop-items konfigureres via Unity-editoren.Projektet blev startet med et færdigt "gold script", der håndterede spillerens valuta, inklusive lagring og visning af guld. 
                    Dette script dannede fundamentet for hele shop-systemet. Dernæst blev et ShopManager-script udviklet med målet om at undgå hårdkodning og i stedet lade shop-items konfigureres via Unity-editoren. Hvert item kunne defineres med navn, pris og billede, hvilket gjorde løsningen både fleksibel og skalerbar i forhold til fremtidig udvidelse.
                </p>

                <p>
                    Gold-systemet blev senere omstruktureret til at følge en mere SOLID-venlig arkitektur. 
                    Et interface, IGoldManager, blev introduceret for at abstrahere logikken for at tilføje, bruge og hente guld. 
                    GoldManager-klassen implementerer dette interface og indeholder ansvar for datahåndtering (PlayerPrefs), UI-opdatering og Singleton-initialisering. 
                    Denne opdeling giver en klar separation af ansvar og øger genbrugelighed og testbarhed i koden. UML-diagrammet nedenfor illustrerer denne struktur og viser tydeligt, hvordan GoldManager implementerer interfacet og kapsler logikken ind.
                </p>

                <p>
                  UI blev designet med mobilanvendelse i tankerne. Herunder blev en Scroll View konfigureret korrekt til mobil, og shop-items blev lagt ind som prefabs med Vertical Layout Group og Content Size Fitter, så visningen automatisk tilpasser sig forskellige skærmstørrelser. 
                  Derudover blev der arbejdet med responsiv opbygning, hvor knapper og layout automatisk justeres afhængigt af opløsning og format, hvilket sikrer en ensartet oplevelse på tværs af enheder.
                </p>

                <p>
                    Købsfunktionen blev koblet til ShopManager, så det automatisk valideres, om spilleren har nok valuta til at gennemføre et køb. Systemet blev desuden udbygget, så det let kunne udvides med yderligere logik – eksempelvis opdatering af en kosmetik-liste, eller integration med andre scener og systemer i spillet.
                </p>

                <h3>Integration med ARFaceList</h3>
                <p>
                  Som en del af shop-funktionaliteten blev der arbejdet på at integrere købte AR-face-prefabs direkte i en ARFaceList, som bruges af AR-systemet i Skattekammer-scenen. 
                  Løsningen gjorde det muligt for spilleren at købe kosmetiske ansigtsgenstande (f.eks. masker), som derefter blev tilføjet automatisk til en liste (ScriptableObject). 
                  Denne liste blev brugt af FacePrefabSelector i AR-scenen til at vise og skifte mellem de købte ansigter. Shoppen blev dermed direkte koblet til AR-oplevelsen, og implementeringen understøttede dynamisk opbygning uden hårdkodning.
                </p>

                <p>
                    Selvom løsningen teknisk fungerede og opfyldte kravene, blev den ikke et elementært delelement i det endelige projekt. 
                    Undervejs i forløbet blev der identificeret en anden metode, som bedre matchede projektets behov og mål – både med hensyn til performance, fleksibilitet og brugeroplevelse. 
                    Derfor blev metoden fravalgt til fordel for en mere effektiv tilgang, men arbejdet med denne del har givet vigtig indsigt i integration mellem shop-system og runtime-data i Unity.
                </p>

                <h3>Udvikling og Justering af AR-Produkter til Virtuel Butik</h3>
                <p>
                  Efter afslutningen af den indledende udvikling af butikken blev fokus rettet mod implementeringen af de produkter,
                  som brugerne kunne købe og interagere med. Den oprindelige intention var at benytte Full Body Tracking til at skabe virtuelle "kostumer",
                  som brugerne kunne iføre sig og tage billeder af i augmented reality (AR).
                  Efter adskillige timers arbejde viste det sig dog,
                  at Unitys dokumentation - i det med småt - angav,
                  at fuld kropssporing udelukkende understøttes på iOS-enheder.
                </p>

                <p>
                  Da projektets målplatform udelukkende anvender Samsung-enheder og gør brug af Google ARCore,
                  var denne funktionalitet desværre ikke anvendelig.
                  Projektgruppen måtte derfor revurdere strategien og vendte tilbage til tegnebrættet.
                  Det blev besluttet at anvende Face Tracking som alternativ.
                  Denne tilgang tillod stadig brugeren at tage billeder af sig selv i AR,
                  hvilket stemte overens med kravspecifikationen, hvor metoden til at tage billedet ikke var nærmere defineret.
                </p>

                <p>
                  For at påbegynde implementeringen af Face Tracking blev Unitys Learning Path for teknologien gennemgået.
                  Herefter blev der udviklet en klasse til håndtering af ansigtsfiltre. Denne klasse gjorde det muligt at tilføje og bladre mellem forskellige filtre.
                  For at gøre systemet mere skalerbart og integrerbart med butikken,
                  blev filtrene struktureret som ScriptableObjects, der indeholder en liste over tilgængelige filtre.
                  En metode til dynamisk at tilføje nye filtre blev tilføjet, hvilket gør det muligt at knytte købte varer til filtrene,
                  således at et filter bliver tilgængeligt for brugeren efter køb.
                </p>
                  <img src="Images/ARFace.png" alt="DevArt" class="image">
                <p>
                  Efterfølgende blev der udviklet en funktionalitet til at tage billeder og gemme dem i brugerens kamerarulle.
                  Et tidligt teknisk problem bestod i, at UI-elementerne, som anvendes til at tage billeder,
                  fortsatte med at være synlige på det færdige billede. Dette blev løst ved at konvertere fotofunktionen til en IEnumerator-metode,
                  som sikrer sekventiel udførelse. Inden selve billedet tages, sættes UI-elementernes alfaværdi til 0 (gennemsigtige),
                  og efter billedet er gemt, sættes alfaværdien tilbage til 255 (fuldt synlig).
                  Billedet gemmes via en platformsspecifik filsti tilpasset Android/Samsung-enheder,
                  og brugeren modtager samtidig en Toast-meddelelse med bekræftelse af, at billedet er gemt.
                </p>

                <p>
                  Afslutningsvis blev AndroidManifest.xml opdateret,
                  så applikationen eksplicit anmoder om tilladelse til at benytte kameraet -
                  analogt med hvordan tilladelser til lokationstracking håndteres.
                  Dette skridt er taget for at sikre overholdelse af gældende lovgivning vedrørende brugen af kamera og persondata.
                </p>

                <h3>Implementering af tværgående funktionalitet mellem scener: Butik og AR-ansigtsfiltre</h3>

                <p>I dette sprint blev der fokuseret på at udvikle funktionalitet, der forbinder eksisterende systemer på tværs af scener,
                   nærmere bestemt interaktionen mellem butiksscenen og "skattekammeret",
                   hvor brugeren har mulighed for at benytte ansigtsfiltre i et AR-miljø.
                   Formålet var at gøre det muligt for brugeren at købe ansigtsfiltre i butikken og efterfølgende anvende disse i skattekammeret til at tage billeder.</p>

                <p>Implementeringen blev realiseret gennem en metode, der først validerer,
                  om brugeren har tilstrækkelige midler i form af "guld" (håndteret via et eksisterende Gold-script) til at foretage et køb.
                  Herefter undersøges det, om den valgte vare er gyldig. Hvis begge betingelser er opfyldt,
                  tilføjes det pågældende ansigtsfilter (repræsenteret som et prefab) til en liste over tilgængelige filtre for brugeren.
                  Denne funktionalitet blev realiseret ved hjælp af scriptet ARFaceFilters, som håndterer brugerens samling af filtre.</p>
                  
                <p>et væsentligt aspekt af denne opgave var at sikre persistens, så købte varer forbliver tilgængelige på tværs af sessioner.
                  Da Unitys PlayerPrefs og JSON-format ikke understøtter direkte lagring af GameObject-referencer, blev der i stedet valgt en løsning,
                  hvor navnene på de købte filtre gemmes som strings i JSON-format. Disse gemmes i PlayerPrefs,
                  og ved genstart af applikationen indlæses navnene og matches mod en statisk liste over alle tilgængelige ansigtsfiltre i systemet.
                  Ved et match rekonstrueres brugerens samling, hvilket sikrer, at købte varer forbliver tilgængelige.</p>

                <p>Når et køb er gennemført, fratrækkes den relevante mængde guld fra brugerens saldo.
                   Det købte produkt fjernes derefter fra butikkens udbud, og butikken opdateres, så kun ikke-købte varer vises.
                   Købsstatussen gemmes ligeledes i PlayerPrefs, hvilket forhindrer brugeren i at købe den samme vare mere end én gang.</p>

                <p>Denne løsning understøtter således både funktionel integration mellem separate scener og sikrer datavedholdelse for brugerens købte indhold,
                   hvilket er centralt for en konsistent brugeroplevelse.</p>

                <h3>AR World Scene </h3>

                <p>
                  AR world scenen er alt hvad der vises af 3d rum på telefonen, når AR er aktiveret. 
                  For at have et centralt sted at tilføje og fjerne ting fra denne scene er Factory mønsteret oplagt.  
                </p>

                <p>
                  Klassen WorldSpawnControlleren er ansvarlig for oprettelsen af instantieringen af 3d modeller fra Skatte event og Juvel event i AR scenen. 
                  Factory controlleren har subscribet til en række events, der signalerer hvad og hvor noget skal spawne. 
                  Factory mønsteret sikrer, at der er en nem og stabil måde at udvide systemet i fremtiden, fx hvis der skulle implementerers en AR-rutevejledning. 
                </p>

                <p>
                  Der var ikke specielt meget diskussion om hvordan dette burde implementeres, da factory mønstret er åbenlyst velegnet til formålet.  
                </p>

                <h3>Implementering af miniGame System</h3>

                <p>I dette sprint blev det besluttet at fokusere på at færdiggøre selve kernen af spiloplevelsen - det,
                   vi betegner som "skattejagten". Den primære målsætning var at etablere funktionaliteten omkring interaktionen med en kongekrone,
                   som fungerer som udgangspunkt for en række minispil.
                   Når spilleren interagerer med kronen, skal et tilfældigt minispil aktiveres, hvilket,
                   ved succesfuld gennemførelse, belønner spilleren med en vis mængde guld.</p>

                <p>For at sikre systemets fleksibilitet og fremtidige udvidelsesmuligheder
                   blev der valgt en arkitektonisk løsning baseret på Strategy Pattern.
                   Denne tilgang muliggør nem integration af nye minispil uden behov for at ændre den eksisterende logik.
                   Et centralt element i implementeringen var en MiniGameManager, som automatisk identificerer og registrerer alle spil,
                   der implementerer det definerede IMiniGame interface. Ved aktivering udvælges et af disse spil tilfældigt.</p>

                <p>Eftersom alle spilkomponenter er afhængige af Unitys MonoBehaviour,
                   blev der oprettet en abstrakt klasse, MiniGameBase,
                   som fungerer som bindeled mellem IMiniGame og de konkrete spiltyper.
                   Denne løsning muliggør, at minispil både kan nedarve fra MonoBehaviour og samtidig overholde IMiniGame interfacet.</p>

                <h3>Valg og Implementering af Minispil</h3>

                <p>Til at begynde med blev der udviklet tre minispil,
                   som alle tager udgangspunkt i kendte spilmekanikker for at sikre høj brugerforståelse og lav indlæringskurve.
                  Disse er:</p>

                <ul>
                  <li><b>KingClicker:</b> inspireret  af "Cookie Clicker</li>
                  <li><b>FlappyKing:</b> inspireret af "flappy Bird</li>
                  <li><b>CatchKing:</b> inspireret af klassiske "dropper"-spil </li>
                </ul>

                <img src="Images/Flappyking.png" alt="DevArt" class="image">
                <p>Alle minispil blev implementeret som UI-elementer,
                   hvilket reducerede den tekniske kompleksitet,
                   men medførte visse begrænsninger i brugen af fysiske komponenter såsom colliders og transforms.</p>

                <h4>KingClicker</h4>
                <p>Dette var det første spil, der blev implementeret.
                   Spillet går ud på, at spilleren optjener guld ved at klikke gentagne gange på en kongekrone inden for en begrænset tidsramme.
                   Tidens udløb vises via en grafisk UI-slider. Spillet er simpelt i sin mekanik,
                   men tjener som en effektiv introduktion til minispilssystemet.</p>

                  <h4>FlappyKing</h4>
                  <p>Dette spil er en UI-baseret version af "Flappy Bird",
                     hvor spilleren styrer en faldende kongekrone ved at trykke på skærmen for at få den til at stige.
                     Målet er at navigere gennem rør og optjene guld. 
                     En teknisk udfordring i dette spil var,
                     at UI-elementer i Unity ikke understøtter klassiske fysiske komponenter som colliders.
                     Derfor blev logikken implementeret ved hjælp af RectTransform overlap-tjek frem for fysiske kollisioner.
                     På trods af dette lykkedes det at skabe en oplevelse, der minder om originalen.</p>

                  <h4>CatchKing</h4>
                  <p>Det sidste spil, der blev udviklet i denne sprint, var CatchKing.
                     Her falder både kroner og bomber ned over skærmen,
                     og spilleren skal forsøge at samle så mange kroner som muligt uden at røre bomberne.
                     Spillet benytter sig af en Object Pooling-mekanisme til at håndtere de faldende elementer effektivt.
                     En udfordring her var at sikre korrekt interaktion mellem objekterne i puljen og brugerens input,
                     hvilket dog blev løst tilfredsstillende.</p>

                  <h3>Integration og Visuelle Forbedringer</h3>

                  <p>Efter implementeringen af de individuelle spil blev MiniGameManager integreret med kongekronen i spilverdenen.
                     Det betyder, at hver gang en krone genereres i spillet,
                     medfølger funktionaliteten til at starte minispil direkte ved interaktion.
                     Derudover blev der udviklet en separat klasse, der håndterer rotationen af kongekronen
                     for at give en animeret og mere iøjnefaldende præsentation, hvilket bidrager til et mere levende og dynamisk visuelt udtryk.</p>

                  <p>Det samlede resultat af sprintet er et fleksibelt og skalerbart minispilssystem,
                     der gør det muligt for udviklere nemt at tilføje nye spil blot ved at implementere
                     det eksisterende interface og arve fra den abstrakte MiniGameBase klasse.
                     Denne arkitektur sikrer en nem vedligeholdelse og udvidelse af systemet i fremtidige iterationer
                     og understøtter videreudviklingen af den samlede spiloplevelse.</p>

                    <h3>Implementering af point-system (ScoreTracker)</h3>

                    <p> 
                        For at udvide shop-systemet og øge spillerens motivation blev et nyt pointsystem implementeret sideløbende med det eksisterende guld. 
                        Ideen bag systemet var, at spilleren optjener point hver gang der optjenes guld, men uden at miste disse point ved køb. 
                        På den måde fungerer point som en form for "samlet optjent guld", som giver et billede af den langsigtede progression.
                    </p>

                    <p>
                        Systemet blev designet ud fra SOLID-principper – særligt Single Responsibility og Dependency Inversion. 
                        Logikken blev derfor delt op i interfaces: IAddScore og IGetScore, og selve tracking-klassen ScoreTrackerSeparated blev isoleret fra UI. 
                        UI-delen blev håndteret af en separat ScoreTrackerPresenter, som kommunikerer via SetPresenter(...)-metoden. 
                        Denne opdeling gør systemet lettere at vedligeholde og udvide, f.eks. hvis man senere vil vise point på flere UI-elementer eller skifte lagringsmetode.
                    </p>

                    <h3>Leaderboard og integration med point-systemet</h3>
                      
                    <img src="Images/Leaderboard.png" alt="DevArt" class="image" style="width: 300px; height: auto;">
                    
                    <p>
                        Et leaderboard blev tilføjet som en afsluttende del af point-systemet, så spilleren kan sammenligne sin score med andre. 
                        Dette system blev bygget ud fra en Unity-pakke leveret af Pelle, som indeholdt scripts som SubmitScorePanel, ScoreView, ScoreList, LeaderBoard, HighscoreData og AddScore.
                    </p>

                    <p>
                        Leaderboardet blev integreret med det eksisterende ScoreTrackerSeparated og ScoreTrackerPresenter-system ved at ændre SubmitScorePanel-scriptet. 
                        I stedet for manuelt indtastede scores hentes spillerens faktiske score nu automatisk og vises i et låst felt. 
                        Dette bidrager til en mere brugervenlig oplevelse og forbedrer dataintegriteten. Til integrationen blev der benyttet en API Key og et Game ID udleveret af Pelle, som konfigureres i HighscoreData for at muliggøre ekstern lagring og visning af highscores.
                    </p>

                    <b>API Key:</b>
                    <p>
                        6d5ad9adc2e3ecc525b288b9af5719f0b6b082352715ab8f8efa03daa012e6c3
                    </p>

                    <b>ID:</b>
                    <p>
                        SEP2-AR-RRI
                    </p>

                    <p>
                        UI'et fra pakken blev også tilpasset, så det visuelt passede med resten af projektet og fungerede på mobil. 
                        Selvom vi oprindeligt vurderede, at opgaven ville tage omkring 100 story points, viste det sig, at den reelle arbejdsbyrde var tættere på 16 story points, da koden i høj grad allerede var givet og kun krævede integration og justeringer.
                    </p>

                    <h3>Unit- og integrationstesting</h3>

                    <p>
                        Med hensigt på regelmæssigt testing, især før push af ændringer, blev implementationen af unit tests startet tidligt i projektet.
                        Implementationen var anderledes end blot at unit teste c# scripts og der var derfor en læringskurve i forhold til vaner og routiner.
                        En stor grund til dette var at mange af de inputs som spillet gør brug af befinder sig i MonoBehaviour klassen som er del af det aktive spil miljø. 
                        Disse inputs kan unit testing ikke tilgå og der blev derfor brugt mere tid på integrationstest i form af Unitys "PlayMode" tests, som inkluderer oprettelse af et spilmiljø.
                    </p>

                    <p>
                        Skattejagsscenen bliver testet for følgende funktioner: Instantiering af scenen, opstart af navigationssystemet, signal fra juvel controllere, 
                        signal fra skatte event controlleren, instantiering af juveler, instantiering af skatte event, tilføjelse af guld og point og opdatering af visuel repræsnetation af spiller- og lokations retninger.
                        Efter indledende fejlede forsøg lykkedes det at opsætte et simuleret test miljø, som AR suiten i Unity genkender. Dette muliggjorde yderligere at teste plane-detection samt synkronisering med orientering i AR.
                    </p>

                    <p>
                      Oprindeligt var alle tests defineret for sig selv, men grundet brugen af prefabs i scenen fejlede nogle af disse grundet flere instantieringer af objekter som ellers ikke ville forekomme.
                      Derfor blev alle tests samlet i én, som sikrede at scenen og andre prefabs kun instantieres én gang hvilket undgik unødvendige fejl på tests. 
                      Testene udnytter funktionen WaitUntil() som muliggører at vente til et bestemt event sker før fortsættelse af test, hvilket gav bedre mulighed for at simulere forskellige situationer.
                    </p>


                    <h3>Fejlhåndtering</h3>

                    <h4>Kompas komplikationer</h4>

                    <p>
                        Den oprindelige implementation af kompasset gjorde brug af Unitys gamle "Input" system, det samme som projektet udnytter til GPS-data.
                        Dog ved det endelige build returnede Input funktionen "magneticHeading", som koden ellers var skrevet rundt om, altid 0 uanset hvordan enheden blev holdt.
                        Ved nærmere eftersyn viste det sig at kompas funktionaliteten var forældet og ikke længere understøttet. I denne sammenhæng blev gruppen enig om at terminere
                        det daværende sprint (7. Sprint) for at fokusere på at lave en løsning til denne vigtige del af projektet.
                    </p>

                    <p>
                        Herfra blev skiftet lavet til det nye input system. Efter kig i dokumentationen blev det dog tydeligt at kompas implementationen ikke var overført til det nye input system,
                        hvor der i stedet var en funktion der kaldte en sensor, MagneticFieldSensor, som registrer der omkringværende ambiente magnetfelt af enheden. 
                        Sensoren returnerer en Vector3, der beskriver telefonens placering ud fra magnetfeltet, hvor x, y og z repræsentere henholdsvis nord / syd aksen, øst / vest, og op / ned.  
                    </p>

                    <p>
                        Magnetfeltssensoren har en række fordele over det 2dimensionelle kompas. Primært den at beregning af telefonens relation til nord er muliggjordt i enhver position. 
                        Dette betyder at brugeren undgår at skulle holde enheden vandret for at finde den korrekte nord.
                        Inklusionen af en tredje akse, z, giver også mulighed for at bestemme orientationen af skærmen, som dog ikke endte med at blive relevant for projektet.
                    </p>

                    <img src="Images/Kompaskode.jpg" alt="kompas kode" class="image">
                    
                    <p>
                        Implementationen af kompasset afhænger af atan2 funktionen. Denne funktion returnerer vinklen mellem to punkter, baseret på en fuld cirkel. 
                        Implementationen er bygget ud fra guiden "how to convert magnetometer data into compass heading". (https://digilent.com/blog/how-to-convert-magnetometer-data-into-compass-heading/)
                        Der oprindeligt er baseret på en Arduinos magnetfeltssensor. Efter eksperimentation blev det tydeligt at denne guides x og y akse er byttet om i forhold til retur typen af Unitys brug af sensoren.
                        Dette betød at retningen af øst og vest på enheden var omvendt, hvilket blev løst ved at vende fortegnet på x-aksen.
                    </p>

                    <p>
                      Efter kodningen af databehandlingen af sensorens returnering var færdig var implementationen gnidningsløs. Arkitekturen havde blot et enkelt punkt som afhang af kompas-retningen.
                    </p>

                    <p>
                      Efter grundigere tests blev det dog tydeligt at udregningerne af retningen var fejlagtige. På trods af en liste af unit tests der bekræftede systemets funktionalitet.
                      Efter eksperimentering bundede fejlen ud i en afrundingsfejl, som skyldes brugen af floats til positioner hvor forskelen mellem punkter blev for lille til præcis udregning.
                      De førnævnte tests udnyttede alle hele float værdier og stødte derfor ikke ind i problemet. Løsningen på dette blev at skifte datastrukturen ud med double værdier samt at
                      bruge et Math-namespace som håndterede radianer i doubles i stedet for floats, da Unitys indbyggede math system regner dem i floats. 
                      Ændringen blev lavet ved hjælp af Microsofts sprog model "Copilot" da der var tale om et systematisk og objektiv ændring af data typer som sprogmodeller excellerer i.
                      Efter unit testing med ikke-runde double værdier var kompas systemet implementeret og funktionelt.
                    </p>

                    <h4>Afstand til punkt - Debug</h4>

                    <p>
                      Sent i projektet blev det nødvendigt at tilgå afstanden fra den nuværende position, til et bestemt koordinat. 
                      Brugen af MVP, observer og facade mønsteret gjorde det nemt tilgængeligt at tilgå informationen.
                      Facaden tillader et simpelt adgangspunkt til den ellers omstændige funktion for afstanden mellem to punkter.
                      Herfra var det blot at tilføje afstanden til NavigationSystemData i navigations systemet, så den gennem observer mønstret bliver distribueret til debug presenteren. 
                      Dette tillod gruppen at løbende tjekke værdien for afstanden til næste punkt, og hjalp med fejlfinding at det system.
                    </p>

                    <h4>Konstant instantiering af kroner</h4>

                    <p>
                      Ved test af instantiering af krone-prefabet, som skal ske én gang ved et bestemt punkt og enhedsretning, skete instantieringen konstant. 
                      Udover at dette ikke var den ønskede opførsel førte det også til problemer ved interaktion med objekterne da logikken bag minigames var designet ud fra et maks af 1 krone ad gangen.
                      Der er et par måder at løse det på, fx ved at lave kronen til en enkelt instans så factorien ikke producerer mange forskellige, 
                      eller udvidde locationsmanageren til at kunne holde styr på om en location har spawnet en kongekrone eller ej.
                      En endelig løsning er endnu ikke besluttet. På lang sigt vil der højst sandsynligt være brug for flere informationer fra locationsmanageren og derved vil udviddelsen af denne være optimal. 
                      Samtidigt, kan der opstå tvivl om en bedre løsning ikke kunne være at have en separat manager til locations, som kun tilgås når spillet kører.
                      Grundet denne tvivl om logikken bør være på locationsmanageren, endte løsningen at være at factoriet holder overblik over om en krone er spawnet eller ej. 
                      Dette betyder at det senere vil være nemt at udvide factoriet med en object pool hvis instantieringen af kroner på flere lokationer samtidigt bliver nødvendigt.
                    </p>

                    <p>
                      
                    </p>

              </div>
              <div class="SideNummer"></div>
        </p>
        
        <br>

        

        <h2 id="refleksioner">5. Personlige refleksioner</h2>
        <p>
          <h3>Nikolaj</h3>
          jeg syntes personligt jeg har kunne bidrage med en del til projektet, da jeg har hhaft stor 
          drivkraft og motivation til at få det til at lykkedes. blandt andet føler jeg at jeg har været
          medvirkende til at skubbe projekt meget frem løbende og sørget for at vi kom videre i proccessen.
          der har dog være både fordel og ulemper ved dette, blandt andet ville jeg gerne havde haft at
          jeg fra start af havde lagt noget mere fokus på arkitekturen i projeket og sørget for at det jeg
          lavede tidligt i forløbet var SOLID, da det først er noget jeg begyndte af havde en bedre forståelse 
          for senere i forløbet, hvilket betyd at ting jeg lavede tidligt i forløbet skulle laves om. 
          der er mine "røde" personligheds træk virkligt komme til udtryk, ydeligere har der også været flere 
          fordel og udlember i forbindelse med at jeg har den "røde" personlighed, da vi løbende har valgt
          at rotere mellem de forskellige roller i gruppen, hvilket har til tidere haft en negativ indflydelse
          på mig, da jeg ofte har siddet med en plan for hvordan noget skulle være i mit hovede, men så har en
          projekt ovner vlagt en anden løsning, så der har jeg skulle tilpasse mig til det, hvilket har været
          en udfordring men syntes jeg har været god til at give plads i gruppen og tilpasse mig til det. således
          at jeg ikke har brudt for meget igenem og taget styringen med det helle, dette er dog noget jeg har
          skulle aflære mig slev, da det ligger dybt i mig, kva den kultur i forsvaret jeg kommer fra, hvor
          jeg kva mit tildligere job som sergent har været vant til at tage styringen og have det overordnede ansvar.
          dog syntes jeg at gruppen har været gode til at sammearbejde og jeg har ikke en føglese af at 
          der har været noget hvor jeg har taget styringen over hovedet på andre.
          <p>
          igenem forløbet har jeg fået en klart bedre forstålese for værdigen af både at have en god arkitektur
          og brugen af design patterns, da det har gjort at det krævede markant mindre ændringer i det kode jeg
          har lavet efterfølgende, samt det har været nemmer for gruppen både at kunne forstå og tilslutte deres
          egen kode mere til det jeg har lavet. 
          </p>
          <p>
          særligt i den sidste del af forløbet har jeg kunne mærke mine røde personlighedstræk, da det er svært
          for mig at stå inde for et projekt som ikke er "færdigt" så det har medføret mange overtimeres arbejde
          for at få nået så meget af projket som muligt. specielt i forbindelse med at i vores sidste sprint 
          oplevede vi at en meget essentielt del af vores system ikke virkede, der var det specelt hårdt for
          mig at være i, da det var en del af projket som jeg kun har været delvist involveret i og derfor
          ikke har kunne være en drivende kraft i at få problemmerne til at blive løst, det gav mig en følelse
          af hjælpeløshed, da jeg kun har kunne bidrag med enkelte ting til løsningen af problemet. og har 
          måtte stole på at de vedrørende i gruppen har kunne været i stand til at løse det. dette har dog
          betydet at jeg har taget meget ansvar i at få udarbejdet en masse andre dele af projketet, i mellem
          tiden.
          </p>
          <p>
           generalt syntes jeg at vi har haft en god dynamik i gruppen og at vi har været gode til at
          samarbejde og hjælpe hinanden, til at komme så langt i projektet som vi er resulteret i at være kommet
          </p>

          <h3>Patrick</h3>
          <p>
              Under arbejdet med projektet oplevede jeg, hvor vigtigt det er at udvikle systemer, der er fleksible og lette at vedligeholde. 
              Jeg havde tidligere en tendens til at hardkode funktioner, som fx sceneskift, men under dette projekt blev det meget tydeligt for mig, hvor hurtigt det bliver uoverskueligt i større applikationer. 
              Jeg lærte, at det er langt mere hensigtsmæssigt at arbejde med mere dynamiske løsninger, fx via event-systemer eller konfigurerbare objekter. 
              Det er noget, jeg helt klart vil implementere tidligere i fremtidige projekter.
          </p>

          <p>
              Jeg fandt også ud af, hvor værdifuldt det er at bruge Unitys UI-system med Scroll View, Vertical Layout Group og Content Size Fitter. 
              Det hjalp mig med at lave en brugerflade, der tilpasser sig forskellige skærmstørrelser – især med mobiltelefoner i tankerne. 
              Det gav mig konkret erfaring med, hvordan man kan tænke responsivt design ind fra starten, og jeg blev bedre til at arbejde struktureret med prefabs og editorbaseret konfiguration.
          </p>

          <p>
              Under arbejdet med at forbinde shop-funktionen med AR-face-funktionaliteten lærte jeg meget om, hvordan man kan arbejder med ScriptableObjects og dynamisk datahåndtering i Unity. 
              Det var spændende at prøve på at udvikle en løsning, hvor købte items direkte kunne integreres i AR-oplevelsen i en anden scene, uden at skulle ændre eksisterende scripts. 
              Men på trods af at løsningen teknisk virkede, valgte vi i sidste ende en alternativ metode, der passede bedre til projektets mål. Det var en værdifuld proces, da jeg fik praktisk erfaring med designvalg og lærte at tage højde for både funktionalitet og brugervenlighed i en helhedsorienteret løsning.
          </p>

          <p>
              Implementeringen af pointsystemet gav mig værdifuld erfaring med at tænke i mere strukturerede og skalerbare løsninger. 
              Ved at benytte interfaces og en adskilt Presenter-klasse lærte jeg, hvordan man kan holde sin logik ren og adskilt fra visningen. 
              Det føltes som et skridt i retning af mere professionel softwarearkitektur. Jeg blev også opmærksom på, at selv små systemer – som f.eks. et simpelt scoremodul – kan drage fordel af SOLID-principper, især hvis projektet vokser. 
              Jeg vil tage denne læring med videre til fremtidige projekter, hvor det at strukturere kode tidligt kan spare meget arbejde senere.
          </p>

          <p>
              Arbejdet med leaderboardet var en god øvelse i at integrere andres kode i vores projekt. 
              Det krævede forståelse af, hvordan de eksisterende scripts fungerede, samt hvordan jeg kunne koble dem sammen med mit eget point-system. 
              Det gav mig også en bedre forståelse for, hvordan man skriver kode, der er let at integrere – f.eks. ved brug af interfaces som IGetScore.
          </p>

          <p>
              Overordnet føler jeg, at jeg har udviklet mig meget i forhold til at tænke mere professionelt og langsigtet i min tilgang til både UI-design og opbygningen af systemer. 
              Jeg har fået større forståelse for vigtigheden af at adskille ansvar i koden, arbejde med genanvendelige komponenter og tænke i skalerbare løsninger fra starten. 
              Jeg har lært af mine fejl og set konkret, hvordan små valg tidligt i processen kan gøre stor forskel senere. 
              Det har givet mig både selvtillid og motivation til at arbejde endnu mere målrettet med at skrive robust, fleksibel og vedligeholdelsesvenlig kode i fremtidige projekter.
          </p>
                  
          <h3>Victor</h3>
          <p>
              Jeg mener at jeg har bidraget godt til gruppearbejdet. I forhold til kvantitativt hvor meget kode jeg har skrevet virker det ikke som så meget, men mit arbejde indenfor
              strukturen og arkitekturen af databehandlingen har hjulpet til at gøre projektet mere overskueligt og stemme mere overens med SOLID-principper. Jeg føler jeg har været god til at
              tilbyde indsigt og hjælp i andres kode og derved hjælpe med at troubleshoote. Jeg har desuden stået for validering af størstedelen af scripts der indgår i spillet og har derfor dannet mig et
              godt overblik over projektet og dets indhold.
          </p>

          <p>
              Den vigtigste viden jeg har opnået gennem projektarbejdet er hvor vigtig struktur og ordentlig planlægning er for større projekter. I starten begav jeg mig ud i 
              at lave hvad jeg tænkte var gode systemer men da det senere blev problematisk at koble det op til resten af systemer blev det tydeligt at vi var nødsaget til at sætte os sammen
              og strukturere projektet. 
          </p>

          <p>
              Arbejdet med implementationstests var spændende og gav også ny læring og viden indenfor hvordan det bliver gjordt i Unity. Men det blev også tydeligt at det ikke altid var tilstrækkeligt
              da diverse systemer og data-typer ikke altid fungerede ligeledes ved et build til mobilen. I kommende projekt der udnytter en anden platform end PC, hvor der bliver udviklet på, vil jeg 
              mene der skal prioriteres at teste på enheden tidligere og løbende i processen. 
          </p>

          <p>
              Generelt set synes jeg der har været et godt samabrejde i gruppen hvor alle har været gode til at påtage sig unikke roller, hvor nogen har specialiseret sig mere i bestemte systemer
              andre har lavet flere generelle systemer og nogle har stået mere for det struktuerelle og dokumenteringen af det. På den måde har vi kunne nå relativt langt med projektet mens det har været
              vel struktueret, dokumenteret og stemt overens med SOLID-principper.
          </p>

        </p>
        <div class="SideNummer"></div>
        
        <h2 id="vejledning">6. Refleksioner over vejledning</h2>
        <p>[Indsæt din tekst her]</p>
        <div class="SideNummer"></div>

        <h2 id="Konklusion">7. Konklusion</h2>
        <p>[Indsæt din tekst her]</p>
        <div class="SideNummer"></div>
        
        <h2 id="referencer">8. Referencer</h2>
        <p>[Indsæt din tekst her]</p>
    </div>

    <div class="footer"></div>

    <script src="Scirpt.js"></script>
</body>
</html>
