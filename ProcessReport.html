<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="Style.css">
    <link rel="icon" type="image/x-icon" href="Images/Icon.png">
    <title>Royal GO</title>
</head>
<body>

    <div class="Reporter">
        <ul>
            <li><a href="index.html">ProjektBeskrivelse</a></li>
            <li><a href="ProjektReport.html">ProjektRepport</a></li>
            <li><a href="ProcessReport.html">ProcesReport</a></li>
            <li><a href="Dokumenter/Gruppekontrakt.pdf" target="_blank">Gruppekontrakt</a></li>
        </ul>
    </div>

    <div class="cover">
        <H1>Via University College</H1>

    <br>
    <br>
    <br>
    <br>

    <h1>Royal GO - ProcessReport</h1>

    <br>
    <br>
    <br>
    <br>
    <br>
    

    <h1>Abdul Wahid Hanan, 353400</h1>
    <h1>Nikolaj Bræmer Christen, 354322</h1>
    <h1>Patick Overgaard Blauert, 353829</h1>
    <h1>Peter Hougaard, 353296</h1>
    <h1>Victor Bruun Fassbender, 354361</h1>
    <br>
    <h1>Vejledere:</h1>
    <h1>Henrik Kronborg Pedersen</h1>
    <h1>Søren Klit Lambæk</h1>

    <br>
    <br>
    <br>

    <div class="char-counter" id="charCounter" style="font-weight: bold; font-size: 25px;">Antal Tegn: 0</div>
    <h1>SoftWareInginør XR</h1>
    <h1>2. Semester</h1>
    <h1>05-03-2025 til 31-5-2025</h1>
        
    </div>

    <div class="toc">
        <h3>Indholdsfortegnelse</h3>
        <ul>
            <li><a href="#Indledning">1. Indledning</a></li>
            <li><a href="#Gruppearbejde">2. Gruppearbejde</a></li>
            <li><a href="#Projektopstart">3. Projektopstart</a></li>
            <li><a href="#Projektudførelse">4. Projektudførelse</a></li>
            <li><a href="#refleksioner">5. Personlige refleksioner</a></li>
            <li><a href="#vejledning">6. Refleksioner over vejledning</a></li>
            <li><a href="#Konklusion">7. Konklusion</a></li>
            <li><a href="#referencer">8. Referencer</a></li>
        </ul>
    </div>

    <div class="header">
        <span>Royal Go - Projektbeskrivelse</span>
        <img src="Images/VIA.png" alt="Logo">
        <hr>
    </div>

    <div class="content" id="content">
        <h2 id="Indledning">1. Indledning</h2>
        <p>[Indsæt din tekst her]</p>
        <div class="SideNummer"></div>
        
        <h2 id="Gruppearbejde">2. Gruppearbejde</h2>
        <p>[Indsæt din tekst her]</p>
        <div class="SideNummer"></div>
        
        <h2 id="Projektopstart">3. Projektopstart</h2>
        <p>
            <h3>Projekt indledene Opstart</h3>
            til at starte projekt, begyndte vi at kigge på userstorys, til at danne os et overblik
            over hvad vi vidste vores projekt skulle havde på det opstartende tidspunkt

            <h3>Projekt udførende Opstart</h3>
            projektet opstars fase blev indledt med valget om at burge Unity 6.36f1,
            da dette var den nyeste stabile version er unity på det gældene tispunkt
        </p>
        <div class="SideNummer"></div>
        
        <h2 id="Projektudførelse">4. Projektudførelse</h2>
        <p>
            <h3>Tilgåning af GPS Lokation</h3>

         <div class="container">
            <img src="Images/anmodomtilladelse.jpg" alt="anmodning om tilladelse" class="image">
                <p>
                  Da applikationen gør brug af GPS-lokationer ved at tilgå GPS-signaler fra brugerens enhed,
                  er det essentielt, at denne funktion håndteres i overensstemmelse med gældende lovgivning,
                  herunder persondataforordningen (GDPR). I henhold til artikel 6, stk. 1 i GDPR,
                  kræves et gyldigt retsgrundlag for behandling af personoplysninger, herunder lokaliseringsdata.
                  For at sikre, at behandlingen sker lovligt, tages der udgangspunkt i Digitaliseringsstyrelsens "Huskeregler for app-udbydere",
                  hvor det blandt andet anbefales at være gennemsigtig omkring anvendelsen af GPS samt at indhente eksplicit
                  samtykke ved opstart af applikationen.
                <br><br>
                  Implementeringen sker ved, at der i AndroidManifest-filen angives,
                  at tilladelse til adgang til lokaliseringsdata er nødvendig for,
                  at applikationen kan fungere. Derudover anvendes scriptet AccessLocationPermission,
                  som først kontrollerer, om brugeren overhovedet har givet tilladelse til,
                  at applikationer må benytte GPS-signaler. Såfremt denne tilladelse foreligger,
                  anmoder applikationen direkte brugeren om adgang til GPS-data for den specifikke app.
                  Først når begge tilladelser er givet, aktiveres GPS-sporingen ved hjælp af funktionen Input.location.Start().
                <br><br>
                  Af hensyn til dataminimering og for at sikre, at brugerens lokation ikke spores unødigt,
                  anvendes den indbyggede metode OnApplicationQuit(), hvor Input.location.Stop() kaldes.
                  Herved sikres det, at sporing udelukkende finder sted under aktiv brug af applikationen,
                  hvilket er i overensstemmelse med GDPR's principper om proportionalitet og dataminimering.
                </p>
            </div>
            <br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint">
            <div class="SideNummer"></div>

            <div class="page-break">
                <br class="onlyonprint"><br class="onlyonprint">
                <h3>Brug af GPS signal</h3>
            I den første iteration af applikationen skal systemet kunne få adgang til oplysninger om brugerens placering og sammenligne,
            om brugeren befinder sig på samme sted som en given position.
            For at opnå adgang til brugerens latitude og longitude kan metoderne
            input.location.lastData.latitude og input.location.lastData.longitude anvendes,
            når funktionen input.location.start() aktiveres. Dette muliggør,
            at systemet med hver opdatering kan registrere brugerens aktuelle koordinater (latitude og longitude).
            Derudover bør der implementeres et system til position sammenligning,
            idet målet er at udvikle et succesfuldt og langtidsholdbart software.
            For at sikre, at systemet er i overensstemmelse med SOLID-principperne,
            vil Haversine-formlen blive anvendt. Denne formel beregner afstanden mellem
            to punkter på en globus baseret på forskellene i latitude og longitude,
            hvilket sikrer mere præcise resultater, især over større afstande.
            </div>
            <br>
            Anvendelsen af Haversine-formlen vil yderligere muliggøre en fremtidig udvidelse
            af systemet til at dække større geografiske områder, hvis dette skulle blive nødvendigt.
            Når afstanden er beregnet ved hjælp af Haversine-formlen,
            kan den sammenlignes med en forudbestemt maksimal afstand, som systemet accepterer.
            Denne fremgangsmåde kan nemt udvides til at inkludere funktionalitet,
            der muliggør instantiationen af objekter på specifikke positioner.

            <h3>Indsamling af lokations- og kompasinformation</h3>
            
            <p>
              For at imødekomme principperne bag Single Responsibility, som er en del af SOLID-arkitekturen,
              er indsamlingen og den efterfølgende behandling af lokations- og kompasdata adskilt i separate klasser.
              Denne opdeling muliggører en mere effektiv anvendelse af Unitys indbyggede "MonoBehaviour"-package,
              idet databehandling og tilhørende beregninger kan håndteres uden for MonoBehaviour.
              Dette bidrager til en reduceret belastning af brugerens enhed og sikrer en mere ressourceeffektiv drift.
            </p>

            <p>
              Lokations- og kompasdata indsamles gennem henholdsvis klasserne "WorldPos" & "Compas".
              hvor MonoBehaviour anvendes til at tilgå Unitys interne lokationstjeneste. De indsamlede oplysninger gemmes i en attribut kaldet "Lastdata",
              som muliggør tilgængeliggørelse af data i en hensigtsmæssig attribut-struktur.
            </p>

            <h3>Databehandling uden for MonoBehaviour</h3>

            <h4>Anvendelse af Haversine-formlen til afstandsberegning</h4>

            <p>
              I forbindelse med betinget instansiering af kongekroner skal der verificeres, om spilleren befinder sig inden for en given radius af et referencepunkt.
              Denne afstandsberegning udføres ved hjælp af Haversine-formlen og er implementeret uden for MonoBehaviour i klassen "PositionCheck".
              Klassen tilbyder en offentlig metode, som returnerer en bool værdi afhængigt af, om spillerens position og
              objektets position overholder den givne radius.
            </p>

            <h4>Beregning af retning ved hjælp af bearing-formlen</h4>

            <h4></h4>
            <p>
              Udover afstanden skal også spillerens orientering verificeres for at muliggøre instansiering af kongekroner.
              Dette gøres ved anvendelse af bearing-formlen, som beregner vinklen mellem to punkter på en sfærisk overflade. 
              Implementeringen foretages i klassen "DirectionCheck", som er adskilt fra MonoBehaviour.
              Klassen indeholder en metode, der returnerer en bool afhængigt af,
              om vinklen mellem spillerens og objektets position befinder sig inden for en defineret grænseværdi for acceptabel retning.
            </p>

            <h3>opstart af augmented reality (kronjuveler)</h3>

            <div class="container">
                <img src="Images/DevArt.jpg" alt="DevArt" class="image">
              
                <p>
                  Efter at have etableret de fundamentale elementer til opbygningen af vores GPS-baserede system,
                  blev næste skridt at implementere en basal form for augmented reality (AR).
                  I denne forbindelse blev udviklingen af de tilfældigt genererede “kronjuveler” påbegyndt.
                  Disse objekter er placeret i nærheden af spilleren med det formål
                  at gøre dem let tilgængelige uden afhængighed af præcise GPS-koordinater.
                </p>
                <br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint">
                <div class="SideNummer"></div>
              
                <p>
                    <br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint">
                  For at opnå dette blev der udviklet et system baseret på plane detection.
                  Systemet anvender en raycasting-teknik, hvor der med faste tidsintervaller -
                  defineret mellem to inputværdier i sekunder  udsendes en ray fra telefonens kamera.
                  Denne ray fortsætter, indtil den registrerer et plane med en passende størrelse,
                  hvorefter et præfabrikeret objekt (prefab) instansieres på den fundne position.
                  På sigt planlægges dette system optimeret ved brug af objekt-pooling,
                  hvor objekter genbruges frem for at blive destrueret og oprettet på ny.
                  Det nuværende system instansierer dog stadig objekterne dynamisk i nærheden af spilleren.
                </p>
            
                <p>
                  Efter implementeringen af denne funktionalitet var næste skridt at definere interaktionen mellem spilleren og kronjuvelerne.
                  Dette blev realiseret ved, at systemet registrerer spillerens tryk på skærmen og udsender en ray fra dette punkt.
                  Hvis ray'en rammer et objekt, der har det korrekte tag (dvs. identificeres som en “kronjuvel”),
                  aktiveres en funktion, der tilføjer en vis mængde guld til spillerens konto.
                  Objektet destrueres derefter (eller senere i udviklingen returneres til objekt-poolen).
                </p>
              
                <p>
                  I forlængelse heraf blev der også implementeret et simpelt valutasystem,
                  som forbereder spillet på en fremtidig økonomifunktion. Systemet anvender Singleton Design Pattern for at sikre,
                  at den samme instans af valuta - kaldet “guld” - anvendes på tværs af alle scener og spilsituationer.
                  Da guld blot repræsenteres af en integer-værdi, gemmes denne ved hjælp af PlayerPrefs, hvilket sikrer,
                  at spillerens valuta bevares på tværs af spilsessioner - også efter at applikationen er lukket.
                </p>
              
                <p>
                  Samlet set danner disse systemer et grundlag for både spillets AR-elementer og økonomiske mekanismer,
                  og de planlægges løbende optimeret med hensyn til ydeevne og brugervenlighed.
                </p>

                <h3>Lokationssporing og Spilområde</h3>

               <p>
                I denne nyupstartet iteration af systemet introduceres muligheden for sporing af specifikke positioner.
                Dette realiseres gennem en ny objektstruktur kaldet Location. Et Location-objekt indeholder tre variabler:
                en string, der repræsenterer navnet på positionen, samt to floats,
                som angiver henholdsvis breddegrad (latitude) og længdegrad (longitude).
                På baggrund heraf oprettes en liste, Locations, der samler flere Location-objekter og
                danner grundlag for videre funktionalitet, såsom søgning efter specifikke positioner.
                </p>
                
                <p>
                Yderligere introduceres konceptet om et "spilområde" (game area),
                hvilket definerer det geografiske område, inden for hvilket spillet skal foregå.
                Hvis en spiller bevæger sig uden for dette område, modtager vedkommende en besked, der informerer om,
                at han eller hun er uden for det tilladte spilleområde.
                For at bestemme spilområdets centrum anvendes listen af Locations.
                Systemet itererer gennem samtlige Location-objekter og beregner gennemsnittet
                af deres latitude- og longitude-koordinater. Resultatet bliver et centralt punkt,
                som repræsenterer midten af spilområdet.
                Ved hjælp af dette punkt kan systemet foretage en afstandsberegning mellem spilleren og centrum.
                Hvis afstanden er mindre end en foruddefineret radius,
                betragtes spilleren som værende inden for spilområdet;
                overskrides denne radius, anses spilleren for at have forladt området, og vil derved bliver
                informeret vedrørrende dette.
                </p>
                
                <img src="Images/Logo2.png" alt="DevArt" class="image">
                <h3>Logo-design</h3>
                
                <p>
                  Projektet omfattede desuden design af applikationens visuelle identitet gennem udviklingen af et logo. 
                  Logoet blev udformet med en kongekrone placeret over navnet Royal-Go, sat i en serif-skrifttype for at understøtte et klassisk og eksklusivt udtryk. 
                  Farvevalget blev foretaget med henblik på at forstærke appens tematiske fokus på luksus og eventyr. Følgende farver blev anvendt: guld (#FFD700), kongeblå (#4169E1) og baggrundsblå (#3E7ACB).
                </p>
                
                <p>
                  Sammenfattende blev der lagt vægt på at sikre sammenhæng mellem æstetik, funktionalitet og tematik, således at designvalg og tekniske løsninger understøttede applikationens overordnede formål og brugervenlighed.
                </p>

                <h3>Simulator (UI):</h3>
                <p>
                  Udviklingen af mobilapplikationen Royal-Go blev gennemført med fokus på design, 
                  brugergrænseflade og visuel identitet. I udviklingsfasen blev der udarbejdet en funktionel og intuitiv brugergrænseflade målrettet mobile enheder. 
                  Startmenuen blev designet til at give adgang til tre centrale funktioner: Skattejagt, Skattekammer og Butik, hvor navigationen mellem scener blev realiseret gennem et skript i Unity. 
                  Et indkøbskurvsikon blev integreret som en grafisk navigationsknap, der skaber visuel og funktionel sammenhæng til butiksscenen.
                </p>

                <p>
                    Til den tekniske implementering blev C# anvendt i Unity-miljøet. 
                    For at muliggøre hurtig prototypeudvikling blev navigation og funktionalitet hardkodet, velvidende at denne metode er mindre skalerbar i større produktionsmiljøer, men egnet til en effektiv tidlig version.
                </p>

                <h3>Udvikling af ButikScene</h3>

                <p>
                  Dette projekt har haft som mål at udvikle en shop-funktion i Unity, hvor spilleren kan købe kosmetiske genstande for en opsamlet valuta (guld). 
                  Udviklingsprocessen har bestået af en iterativ tilgang, hvor funktionalitet gradvist blev udvidet og testet i sammenhæng med brugergrænseflade og gameplay-integration.
                </p>

                <p>
                    Projektet blev startet med et færdigt "gold script", der håndterede spillerens valuta, inklusive lagring og visning af guld. Dette script dannede fundamentet for hele shop-systemet. 
                    Dernæst blev et ShopManager-script udviklet med målet om at undgå hårdkodning og i stedet lade shop-items konfigureres via Unity-editoren.
                </p>

                <p>
                  UI blev designet med mobilanvendelse i tankerne. 
                  Herunder blev en Scroll View konfigureret korrekt til mobil, og shop-items blev lagt ind som prefabs med Vertical Layout Group og Content Size Fitter, 
                  så visningen automatisk tilpasser sig forskellige skærmstørrelser.
                </p>

                <h3>Integration med ARFaceList</h3>
                <p>
                  Som en del af shop-funktionaliteten blev der arbejdet på at integrere købte AR-face-prefabs direkte i en ARFaceList, som bruges af AR-systemet i Skattekammer-scenen. 
                  Løsningen gjorde det muligt for spilleren at købe kosmetiske ansigtsgenstande (f.eks. masker), som derefter blev tilføjet automatisk til en liste (ScriptableObject). 
                  Denne liste blev brugt af FacePrefabSelector i AR-scenen til at vise og skifte mellem de købte ansigter. Shoppen blev dermed direkte koblet til AR-oplevelsen, og implementeringen understøttede dynamisk opbygning uden hårdkodning.
                </p>

                <p>
                    Selvom løsningen teknisk fungerede og opfyldte kravene, blev den ikke et elementært delelement i det endelige projekt. 
                    Undervejs i forløbet blev der identificeret en anden metode, som bedre matchede projektets behov og mål – både med hensyn til performance, fleksibilitet og brugeroplevelse. 
                    Derfor blev metoden fravalgt til fordel for en mere effektiv tilgang, men arbejdet med denne del har givet vigtig indsigt i integration mellem shop-system og runtime-data i Unity.
                </p>

                <h3>Udvikling og Justering af AR-Produkter til Virtuel Butik</h3>
                <p>
                  Efter afslutningen af den indledende udvikling af butikken blev fokus rettet mod implementeringen af de produkter,
                  som brugerne kunne købe og interagere med. Den oprindelige intention var at benytte Full Body Tracking til at skabe virtuelle "kostumer",
                  som brugerne kunne iføre sig og tage billeder af i augmented reality (AR).
                  Efter adskillige timers arbejde viste det sig dog,
                  at Unitys dokumentation - i det med småt - angav,
                  at fuld kropssporing udelukkende understøttes på iOS-enheder.
                </p>

                <p>
                  Da projektets målplatform udelukkende anvender Samsung-enheder og gør brug af Google ARCore,
                  var denne funktionalitet desværre ikke anvendelig.
                  Projektgruppen måtte derfor revurdere strategien og vendte tilbage til tegnebrættet.
                  Det blev besluttet at anvende Face Tracking som alternativ.
                  Denne tilgang tillod stadig brugeren at tage billeder af sig selv i AR,
                  hvilket stemte overens med kravspecifikationen, hvor metoden til at tage billedet ikke var nærmere defineret.
                </p>

                <p>
                  For at påbegynde implementeringen af Face Tracking blev Unitys Learning Path for teknologien gennemgået.
                  Herefter blev der udviklet en klasse til håndtering af ansigtsfiltre. Denne klasse gjorde det muligt at tilføje og bladre mellem forskellige filtre.
                  For at gøre systemet mere skalerbart og integrerbart med butikken,
                  blev filtrene struktureret som ScriptableObjects, der indeholder en liste over tilgængelige filtre.
                  En metode til dynamisk at tilføje nye filtre blev tilføjet, hvilket gør det muligt at knytte købte varer til filtrene,
                  således at et filter bliver tilgængeligt for brugeren efter køb.
                </p>

                <p>
                  Efterfølgende blev der udviklet en funktionalitet til at tage billeder og gemme dem i brugerens kamerarulle.
                  Et tidligt teknisk problem bestod i, at UI-elementerne, som anvendes til at tage billeder,
                  fortsatte med at være synlige på det færdige billede. Dette blev løst ved at konvertere fotofunktionen til en IEnumerator-metode,
                  som sikrer sekventiel udførelse. Inden selve billedet tages, sættes UI-elementernes alfaværdi til 0 (gennemsigtige),
                  og efter billedet er gemt, sættes alfaværdien tilbage til 255 (fuldt synlig).
                  Billedet gemmes via en platformsspecifik filsti tilpasset Android/Samsung-enheder,
                  og brugeren modtager samtidig en Toast-meddelelse med bekræftelse af, at billedet er gemt.
                </p>

                <p>
                  Afslutningsvis blev AndroidManifest.xml opdateret,
                  så applikationen eksplicit anmoder om tilladelse til at benytte kameraet -
                  analogt med hvordan tilladelser til lokationstracking håndteres.
                  Dette skridt er taget for at sikre overholdelse af gældende lovgivning vedrørende brugen af kamera og persondata.
                </p>

                <h3>Implementering af tværgående funktionalitet mellem scener: Butik og AR-ansigtsfiltre</h3>

                <p>I dette sprint blev der fokuseret på at udvikle funktionalitet, der forbinder eksisterende systemer på tværs af scener,
                   nærmere bestemt interaktionen mellem butiksscenen og "skattekammeret",
                   hvor brugeren har mulighed for at benytte ansigtsfiltre i et AR-miljø.
                   Formålet var at gøre det muligt for brugeren at købe ansigtsfiltre i butikken og efterfølgende anvende disse i skattekammeret til at tage billeder.</p>

                <p>Implementeringen blev realiseret gennem en metode, der først validerer,
                  om brugeren har tilstrækkelige midler i form af "guld" (håndteret via et eksisterende Gold-script) til at foretage et køb.
                  Herefter undersøges det, om den valgte vare er gyldig. Hvis begge betingelser er opfyldt,
                  tilføjes det pågældende ansigtsfilter (repræsenteret som et prefab) til en liste over tilgængelige filtre for brugeren.
                  Denne funktionalitet blev realiseret ved hjælp af scriptet ARFaceFilters, som håndterer brugerens samling af filtre.</p>
                  
                <p>et væsentligt aspekt af denne opgave var at sikre persistens, så købte varer forbliver tilgængelige på tværs af sessioner.
                  Da Unitys PlayerPrefs og JSON-format ikke understøtter direkte lagring af GameObject-referencer, blev der i stedet valgt en løsning,
                  hvor navnene på de købte filtre gemmes som strings i JSON-format. Disse gemmes i PlayerPrefs,
                  og ved genstart af applikationen indlæses navnene og matches mod en statisk liste over alle tilgængelige ansigtsfiltre i systemet.
                  Ved et match rekonstrueres brugerens samling, hvilket sikrer, at købte varer forbliver tilgængelige.</p>

                <p>Når et køb er gennemført, fratrækkes den relevante mængde guld fra brugerens saldo.
                   Det købte produkt fjernes derefter fra butikkens udbud, og butikken opdateres, så kun ikke-købte varer vises.
                   Købsstatussen gemmes ligeledes i PlayerPrefs, hvilket forhindrer brugeren i at købe den samme vare mere end én gang.</p>

                <p>Denne løsning understøtter således både funktionel integration mellem separate scener og sikrer datavedholdelse for brugerens købte indhold,
                   hvilket er centralt for en konsistent brugeroplevelse.</p>

                <h3>Implementering af miniGame System</h3>

                <p>I dette sprint blev det besluttet at fokusere på at færdiggøre selve kernen af spiloplevelsen - det,
                   vi betegner som "skattejagten". Den primære målsætning var at etablere funktionaliteten omkring interaktionen med en kongekrone,
                   som fungerer som udgangspunkt for en række minispil.
                   Når spilleren interagerer med kronen, skal et tilfældigt minispil aktiveres, hvilket,
                   ved succesfuld gennemførelse, belønner spilleren med en vis mængde guld.</p>

                <p>For at sikre systemets fleksibilitet og fremtidige udvidelsesmuligheder
                   blev der valgt en arkitektonisk løsning baseret på Strategy Pattern.
                   Denne tilgang muliggør nem integration af nye minispil uden behov for at ændre den eksisterende logik.
                   Et centralt element i implementeringen var en MiniGameManager, som automatisk identificerer og registrerer alle spil,
                   der implementerer det definerede IMiniGame interface. Ved aktivering udvælges et af disse spil tilfældigt.</p>

                <p>Eftersom alle spilkomponenter er afhængige af Unitys MonoBehaviour,
                   blev der oprettet en abstrakt klasse, MiniGameBase,
                   som fungerer som bindeled mellem IMiniGame og de konkrete spiltyper.
                   Denne løsning muliggør, at minispil både kan nedarve fra MonoBehaviour og samtidig overholde IMiniGame interfacet.</p>

                <h3>Valg og Implementering af Minispil</h3>

                <p>Til at begynde med blev der udviklet tre minispil,
                   som alle tager udgangspunkt i kendte spilmekanikker for at sikre høj brugerforståelse og lav indlæringskurve.
                  Disse er:</p>

                <ul>
                  <li><b>KingClicker:</b> inspireret  af "Cookie Clicker</li>
                  <li><b>FalppyKing:</b> inspireret af "flappy Bird</li>
                  <li><b>CatchKing:</b> inspireret af klassiske "dropper"-spil </li>
                </ul>

                <p>Alle minispil blev implementeret som UI-elementer,
                   hvilket reducerede den tekniske kompleksitet,
                   men medførte visse begrænsninger i brugen af fysiske komponenter såsom colliders og transforms.</p>

                <h4>KingClicker</h4>
                <p>Dette var det første spil, der blev implementeret.
                   Spillet går ud på, at spilleren optjener guld ved at klikke gentagne gange på en kongekrone inden for en begrænset tidsramme.
                   Tidens udløb vises via en grafisk UI-slider. Spillet er simpelt i sin mekanik,
                   men tjener som en effektiv introduktion til minispilssystemet.</p>

                  <h4>FlappyKing</h4>
                  <p>Dette spil er en UI-baseret version af "Flappy Bird",
                     hvor spilleren styrer en faldende kongekrone ved at trykke på skærmen for at få den til at stige.
                     Målet er at navigere gennem rør og optjene guld. 
                     En teknisk udfordring i dette spil var,
                     at UI-elementer i Unity ikke understøtter klassiske fysiske komponenter som colliders.
                     Derfor blev logikken implementeret ved hjælp af RectTransform overlap-tjek frem for fysiske kollisioner.
                     På trods af dette lykkedes det at skabe en oplevelse, der minder om originalen.</p>

                  <h4>CatchKing</h4>
                  <p>Det sidste spil, der blev udviklet i denne sprint, var CatchKing.
                     Her falder både kroner og bomber ned over skærmen,
                     og spilleren skal forsøge at samle så mange kroner som muligt uden at røre bomberne.
                     Spillet benytter sig af en Object Pooling-mekanisme til at håndtere de faldende elementer effektivt.
                     En udfordring her var at sikre korrekt interaktion mellem objekterne i puljen og brugerens input,
                     hvilket dog blev løst tilfredsstillende.</p>

                  <h3>Integration og Visuelle Forbedringer</h3>

                  <p>Efter implementeringen af de individuelle spil blev MiniGameManager integreret med kongekronen i spilverdenen.
                     Det betyder, at hver gang en krone genereres i spillet,
                     medfølger funktionaliteten til at starte minispil direkte ved interaktion.
                     Derudover blev der udviklet en separat klasse, der håndterer rotationen af kongekronen
                     for at give en animeret og mere iøjnefaldende præsentation, hvilket bidrager til et mere levende og dynamisk visuelt udtryk.</p>

                  <p>Det samlede resultat af sprintet er et fleksibelt og skalerbart minispilssystem,
                     der gør det muligt for udviklere nemt at tilføje nye spil blot ved at implementere
                     det eksisterende interface og arve fra den abstrakte MiniGameBase klasse.
                     Denne arkitektur sikrer en nem vedligeholdelse og udvidelse af systemet i fremtidige iterationer
                     og understøtter videreudviklingen af den samlede spiloplevelse.</p>
              </div>
              <div class="SideNummer"></div>
        </p>
        
        <br>

        

        <h2 id="refleksioner">5. Personlige refleksioner</h2>
        <p>[Indsæt din tekst her]</p>
        <div class="SideNummer"></div>
        
        <h2 id="vejledning">6. Refleksioner over vejledning</h2>
        <p>[Indsæt din tekst her]</p>
        <div class="SideNummer"></div>

        <h2 id="Konklusion">7. Konklusion</h2>
        <p>[Indsæt din tekst her]</p>
        <div class="SideNummer"></div>
        
        <h2 id="referencer">8. Referencer</h2>
        <p>[Indsæt din tekst her]</p>
    </div>

    <div class="footer"></div>

    <script src="Scirpt.js"></script>
</body>
</html>
