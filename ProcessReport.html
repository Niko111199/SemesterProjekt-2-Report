<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="Style.css">
    <link rel="icon" type="image/x-icon" href="Images/Icon.png">
    <title>Royal GO</title>
</head>
<body>

    <div class="Reporter">
        <ul>
            <li><a href="index.html">ProjektBeskrivelse</a></li>
            <li><a href="ProjektReport.html">ProjektRepport</a></li>
            <li><a href="ProcessReport.html">ProcesReport</a></li>
            <li><a href="Dokumenter/Gruppekontrakt.pdf" target="_blank">Gruppekontrakt</a></li>
        </ul>
    </div>

    <div class="cover">
        <H1>Via University College</H1>

    <br>
    <br>
    <br>
    <br>

    <h1>Royal GO - ProcessReport</h1>

    <br>
    <br>
    <br>
    <br>
    <br>
    

    <h1>Abdul Wahid Hanan, 353400</h1>
    <h1>Nikolaj Bræmer Christen, 354322</h1>
    <h1>Patick Overgaard Blauert, 353829</h1>
    <h1>Peter Hougaard, 353296</h1>
    <h1>Victor Bruun Fassbender, 354361</h1>
    <br>
    <h1>Vejledere:</h1>
    <h1>Henrik Kronborg Pedersen</h1>
    <h1>Søren Klit Lambæk</h1>

    <br>
    <br>
    <br>

    <div class="char-counter" id="charCounter" style="font-weight: bold; font-size: 25px;">Antal Tegn: 0</div>
    <h1>SoftWareInginør XR</h1>
    <h1>2. Semester</h1>
    <h1>05-03-2025 til 31-5-2025</h1>
        
    </div>

    <div class="toc">
        <h3>Indholdsfortegnelse</h3>
        <ul>
            <li><a href="#Indledning">1. Indledning</a></li>
            <li><a href="#Gruppearbejde">2. Gruppearbejde</a></li>
            <li><a href="#Projektopstart">3. Projektopstart</a></li>
            <li><a href="#Projektudførelse">4. Projektudførelse</a></li>
            <li><a href="#refleksioner">5. Personlige refleksioner</a></li>
            <li><a href="#vejledning">6. Refleksioner over vejledning</a></li>
            <li><a href="#Konklusion">7. Konklusion</a></li>
            <li><a href="#referencer">8. Referencer</a></li>
        </ul>
    </div>

    <div class="header">
        <span>Royal Go - Projektbeskrivelse</span>
        <img src="Images/VIA.png" alt="Logo">
        <hr>
    </div>

    <div class="content" id="content">
        <h2 id="Indledning">1. Indledning</h2>
        <p>[Indsæt din tekst her]</p>
        <div class="SideNummer"></div>
        
        <h2 id="Gruppearbejde">2. Gruppearbejde</h2>
        <p>
          <p>
              I projektet arbejdede vi tæt sammen i en gruppe bestående af 4. Peter, Victor, Nikolaj, Patrick, hvor vi hver især bidrog med forskellige kompetencer og faglige styrker. 
              Gruppen bestod af medlemmer med forskellige tekniske baggrunde, hvilket gav anledning til en dynamisk samarbejdsform, hvor opgaver og ansvarsområder blev fordelt i forhold til individuelle kompetencer og interesser.
          </p>

          <p>
              Eventuelle konflikter blev løst konstruktivt gennem åben dialog og respekt for hinandens perspektiver. 
              Vi oplevede generelt en høj grad af engagement, og der var ikke tydelige tilfælde af social loafing. 
              Vi holdt regelmæssige statusmøder til at koordinere kode og sikre fælles fremdrift.
          </p>

          <h3>Patrick</h3>
          <p>
              Mit primære bidrag lå inden for design og teknisk implementering af brugergrænsefladen samt funktionalitet i simulatoren Royal-Go. 
              Jeg var ansvarlig for udviklingen af mobilapplikationens UI, hvor jeg designede startmenuen og implementerede navigation mellem funktionerne Skattejagt, Skattekammer og Butik i Unity ved hjælp af C#. 
              Derudover skabte jeg en visuel identitet for applikationen, herunder logo-design og valg af farvepalette, med fokus på at skabe en sammenhængende og appellerende brugeroplevelse.
          </p>

          <p>
              I samarbejdet arbejdede jeg desuden på udviklingen af butiksscenariet, hvor jeg udviklede et konfigurerbart shop-system, designet til mobilvisning, og integrerede det med spillets valuta og AR-komponenter. 
              Jeg arbejdede iterativt og tilpassede løsningen undervejs, hvilket førte til vigtige læringer om systemintegration og runtime-datahåndtering i Unity.
          </p>

          <p>
              For at styrke brugeroplevelsen og den langsigtede spilprogression implementerede jeg et point-system med principper fra SOLID-arkitektur. 
              Systemet blev koblet til et leaderboard, hvor spillerens score vises og sammenlignes automatisk. 
              Jeg stod for integrationen af API-baseret highscore-visning samt tilpasning af UI til det samlede design.
          </p>

          <p>
              Jeg påtog mig rollerne som "Implementer", hvor jeg fokuserede på at omdanne ideer til funktionelle løsninger og bidrog med teknisk viden inden for UI og spiludvikling i Unity.
          </p>
        </p>
        <div class="SideNummer"></div>
        
        <h2 id="Projektopstart">3. Projektopstart</h2>
        <p>
            <h3>Projekt indledene Opstart</h3>
            til at starte projekt, begyndte vi at kigge på userstorys, til at danne os et overblik
            over hvad vi vidste vores projekt skulle havde på det opstartende tidspunkt

            <h3>Projekt udførende Opstart</h3>
            projektet opstars fase blev indledt med valget om at burge Unity 6.36f1,
            da dette var den nyeste stabile version er unity på det gældene tispunkt
        </p>
        <div class="SideNummer"></div>
        
        <h2 id="Projektudførelse">4. Projektudførelse</h2>
        <p>
            <h3>Tilgåning af GPS Lokation</h3>

         <div class="container">
            <img src="Images/anmodomtilladelse.jpg" alt="anmodning om tilladelse" class="image">
                <p>
                  Da applikationen gør brug af GPS-lokationer ved at tilgå GPS-signaler fra brugerens enhed,
                  er det essentielt, at denne funktion håndteres i overensstemmelse med gældende lovgivning,
                  herunder persondataforordningen (GDPR). I henhold til artikel 6, stk. 1 i GDPR,
                  kræves et gyldigt retsgrundlag for behandling af personoplysninger, herunder lokaliseringsdata.
                  For at sikre, at behandlingen sker lovligt, tages der udgangspunkt i Digitaliseringsstyrelsens "Huskeregler for app-udbydere",
                  hvor det blandt andet anbefales at være gennemsigtig omkring anvendelsen af GPS samt at indhente eksplicit
                  samtykke ved opstart af applikationen.
                <br><br>
                  Implementeringen sker ved, at der i AndroidManifest-filen angives,
                  at tilladelse til adgang til lokaliseringsdata er nødvendig for,
                  at applikationen kan fungere. Derudover anvendes scriptet AccessLocationPermission,
                  som først kontrollerer, om brugeren overhovedet har givet tilladelse til,
                  at applikationer må benytte GPS-signaler. Såfremt denne tilladelse foreligger,
                  anmoder applikationen direkte brugeren om adgang til GPS-data for den specifikke app.
                  Først når begge tilladelser er givet, aktiveres GPS-sporingen ved hjælp af funktionen Input.location.Start().
                <br><br>
                  Af hensyn til dataminimering og for at sikre, at brugerens lokation ikke spores unødigt,
                  anvendes den indbyggede metode OnApplicationQuit(), hvor Input.location.Stop() kaldes.
                  Herved sikres det, at sporing udelukkende finder sted under aktiv brug af applikationen,
                  hvilket er i overensstemmelse med GDPR's principper om proportionalitet og dataminimering.
                </p>
            </div>
            <br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint">
            <div class="SideNummer"></div>

            <div class="page-break">
                <br class="onlyonprint"><br class="onlyonprint">
                <h3>Brug af GPS signal</h3>
            I den første iteration af applikationen skal systemet kunne få adgang til oplysninger om brugerens placering og sammenligne,
            om brugeren befinder sig på samme sted som en given position.
            For at opnå adgang til brugerens latitude og longitude kan metoderne
            input.location.lastData.latitude og input.location.lastData.longitude anvendes,
            når funktionen input.location.start() aktiveres. Dette muliggør,
            at systemet med hver opdatering kan registrere brugerens aktuelle koordinater (latitude og longitude).
            Derudover bør der implementeres et system til position sammenligning,
            idet målet er at udvikle et succesfuldt og langtidsholdbart software.
            For at sikre, at systemet er i overensstemmelse med SOLID-principperne,
            vil Haversine-formlen blive anvendt. Denne formel beregner afstanden mellem
            to punkter på en globus baseret på forskellene i latitude og longitude,
            hvilket sikrer mere præcise resultater, især over større afstande.
            </div>
            <br>
            Anvendelsen af Haversine-formlen vil yderligere muliggøre en fremtidig udvidelse
            af systemet til at dække større geografiske områder, hvis dette skulle blive nødvendigt.
            Når afstanden er beregnet ved hjælp af Haversine-formlen,
            kan den sammenlignes med en forudbestemt maksimal afstand, som systemet accepterer.
            Denne fremgangsmåde kan nemt udvides til at inkludere funktionalitet,
            der muliggør instantiationen af objekter på specifikke positioner.

            <h3>Indsamling af lokations- og kompasinformation</h3>
            
            <p>
              For at imødekomme principperne bag Single Responsibility, som er en del af SOLID-arkitekturen,
              er indsamlingen og den efterfølgende behandling af lokations- og kompasdata adskilt i separate klasser.
              Denne opdeling muliggører en mere effektiv anvendelse af Unitys indbyggede "MonoBehaviour"-package,
              idet databehandling og tilhørende beregninger kan håndteres uden for MonoBehaviour.
              Dette bidrager til en reduceret belastning af brugerens enhed og sikrer en mere ressourceeffektiv drift.
            </p>

            <p>
              Lokations- og kompasdata indsamles gennem henholdsvis klasserne "WorldPos" & "Compas".
              hvor MonoBehaviour anvendes til at tilgå Unitys interne lokationstjeneste. De indsamlede oplysninger gemmes i en attribut kaldet "Lastdata",
              som muliggør tilgængeliggørelse af data i en hensigtsmæssig attribut-struktur.
            </p>

            <h3>Databehandling uden for MonoBehaviour</h3>

            <h4>Anvendelse af Haversine-formlen til afstandsberegning</h4>

            <p>
              I forbindelse med betinget instansiering af kongekroner skal der verificeres, om spilleren befinder sig inden for en given radius af et referencepunkt.
              Denne afstandsberegning udføres ved hjælp af Haversine-formlen og er implementeret uden for MonoBehaviour i klassen "PositionCheck".
              Klassen tilbyder en offentlig metode, som returnerer en bool værdi afhængigt af, om spillerens position og
              objektets position overholder den givne radius.
            </p>

            <h4>Beregning af retning ved hjælp af bearing-formlen</h4>

            <h4></h4>
            <p>
              Udover afstanden skal også spillerens orientering verificeres for at muliggøre instansiering af kongekroner.
              Dette gøres ved anvendelse af bearing-formlen, som beregner vinklen mellem to punkter på en sfærisk overflade. 
              Implementeringen foretages i klassen "DirectionCheck", som er adskilt fra MonoBehaviour.
              Klassen indeholder en metode, der returnerer en bool afhængigt af,
              om vinklen mellem spillerens og objektets position befinder sig inden for en defineret grænseværdi for acceptabel retning.
            </p>

            <h3>opstart af augmented reality (kronjuveler)</h3>

            <div class="container">
                <img src="Images/DevArt.jpg" alt="DevArt" class="image">
              
                <p>
                  Efter at have etableret de fundamentale elementer til opbygningen af vores GPS-baserede system,
                  blev næste skridt at implementere en basal form for augmented reality (AR).
                  I denne forbindelse blev udviklingen af de tilfældigt genererede “kronjuveler” påbegyndt.
                  Disse objekter er placeret i nærheden af spilleren med det formål
                  at gøre dem let tilgængelige uden afhængighed af præcise GPS-koordinater.
                </p>
                <br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint">
                <div class="SideNummer"></div>
              
                <p>
                    <br class="onlyonprint"><br class="onlyonprint"><br class="onlyonprint">
                  For at opnå dette blev der udviklet et system baseret på plane detection.
                  Systemet anvender en raycasting-teknik, hvor der med faste tidsintervaller -
                  defineret mellem to inputværdier i sekunder  udsendes en ray fra telefonens kamera.
                  Denne ray fortsætter, indtil den registrerer et plane med en passende størrelse,
                  hvorefter et præfabrikeret objekt (prefab) instansieres på den fundne position.
                  På sigt planlægges dette system optimeret ved brug af objekt-pooling,
                  hvor objekter genbruges frem for at blive destrueret og oprettet på ny.
                  Det nuværende system instansierer dog stadig objekterne dynamisk i nærheden af spilleren.
                </p>
            
                <p>
                  Efter implementeringen af denne funktionalitet var næste skridt at definere interaktionen mellem spilleren og kronjuvelerne.
                  Dette blev realiseret ved, at systemet registrerer spillerens tryk på skærmen og udsender en ray fra dette punkt.
                  Hvis ray'en rammer et objekt, der har det korrekte tag (dvs. identificeres som en “kronjuvel”),
                  aktiveres en funktion, der tilføjer en vis mængde guld til spillerens konto.
                  Objektet destrueres derefter (eller senere i udviklingen returneres til objekt-poolen).
                </p>
              
                <p>
                  I forlængelse heraf blev der også implementeret et simpelt valutasystem,
                  som forbereder spillet på en fremtidig økonomifunktion. Systemet anvender Singleton Design Pattern for at sikre,
                  at den samme instans af valuta - kaldet “guld” - anvendes på tværs af alle scener og spilsituationer.
                  Da guld blot repræsenteres af en integer-værdi, gemmes denne ved hjælp af PlayerPrefs, hvilket sikrer,
                  at spillerens valuta bevares på tværs af spilsessioner - også efter at applikationen er lukket.
                </p>
              
                <p>
                  Samlet set danner disse systemer et grundlag for både spillets AR-elementer og økonomiske mekanismer,
                  og de planlægges løbende optimeret med hensyn til ydeevne og brugervenlighed.
                </p>

                <h3>Lokationssporing og Spilområde</h3>

               <p>
                I denne nyupstartet iteration af systemet introduceres muligheden for sporing af specifikke positioner.
                Dette realiseres gennem en ny objektstruktur kaldet Location. Et Location-objekt indeholder tre variabler:
                en string, der repræsenterer navnet på positionen, samt to floats,
                som angiver henholdsvis breddegrad (latitude) og længdegrad (longitude).
                På baggrund heraf oprettes en liste, Locations, der samler flere Location-objekter og
                danner grundlag for videre funktionalitet, såsom søgning efter specifikke positioner.
                </p>
                
                <p>
                Yderligere introduceres konceptet om et "spilområde" (game area),
                hvilket definerer det geografiske område, inden for hvilket spillet skal foregå.
                Hvis en spiller bevæger sig uden for dette område, modtager vedkommende en besked, der informerer om,
                at han eller hun er uden for det tilladte spilleområde.
                For at bestemme spilområdets centrum anvendes listen af Locations.
                Systemet itererer gennem samtlige Location-objekter og beregner gennemsnittet
                af deres latitude- og longitude-koordinater. Resultatet bliver et centralt punkt,
                som repræsenterer midten af spilområdet.
                Ved hjælp af dette punkt kan systemet foretage en afstandsberegning mellem spilleren og centrum.
                Hvis afstanden er mindre end en foruddefineret radius,
                betragtes spilleren som værende inden for spilområdet;
                overskrides denne radius, anses spilleren for at have forladt området, og vil derved bliver
                informeret vedrørrende dette.
                </p>
                
                <img src="Images/Logo2.png" alt="DevArt" class="image">
                <h3>Logo-design</h3>
                
                <p>
                  Projektet omfattede desuden design af applikationens visuelle identitet gennem udviklingen af et logo. 
                  Logoet blev udformet med en kongekrone placeret over navnet Royal-Go, sat i en serif-skrifttype for at understøtte et klassisk og eksklusivt udtryk. 
                  Farvevalget blev foretaget med henblik på at forstærke appens tematiske fokus på luksus og eventyr. Følgende farver blev anvendt: guld (#FFD700), kongeblå (#4169E1) og baggrundsblå (#3E7ACB).
                </p>
                
                <p>
                  Sammenfattende blev der lagt vægt på at sikre sammenhæng mellem æstetik, funktionalitet og tematik, således at designvalg og tekniske løsninger understøttede applikationens overordnede formål og brugervenlighed.
                </p>

                <h3>Simulator (UI):</h3>
                <p>
                  Udviklingen af mobilapplikationen Royal-Go blev gennemført med fokus på design, 
                  brugergrænseflade og visuel identitet. I udviklingsfasen blev der udarbejdet en funktionel og intuitiv brugergrænseflade målrettet mobile enheder. 
                  Startmenuen blev designet til at give adgang til tre centrale funktioner: Skattejagt, Skattekammer og Butik, hvor navigationen mellem scener blev realiseret gennem et skript i Unity. 
                  Et indkøbskurvsikon blev integreret som en grafisk navigationsknap, der skaber visuel og funktionel sammenhæng til butiksscenen.
                </p>

                <p>
                    Til den tekniske implementering blev C# anvendt i Unity-miljøet. 
                    For at muliggøre hurtig prototypeudvikling blev navigation og funktionalitet hardkodet, velvidende at denne metode er mindre skalerbar i større produktionsmiljøer, men egnet til en effektiv tidlig version.
                </p>

                <h3>Udvikling af ButikScene</h3>

                <p>
                  Dette projekt har haft som mål at udvikle en shop-funktion i Unity, hvor spilleren kan købe kosmetiske genstande for en opsamlet valuta (guld). 
                  Udviklingsprocessen har bestået af en iterativ tilgang, hvor funktionalitet gradvist blev udvidet og testet i sammenhæng med brugergrænseflade og gameplay-integration.
                </p>

                <p>
                    Projektet blev startet med et færdigt "gold script", der håndterede spillerens valuta, inklusive lagring og visning af guld. Dette script dannede fundamentet for hele shop-systemet. 
                    Dernæst blev et ShopManager-script udviklet med målet om at undgå hårdkodning og i stedet lade shop-items konfigureres via Unity-editoren.
                </p>

                <p>
                  UI blev designet med mobilanvendelse i tankerne. 
                  Herunder blev en Scroll View konfigureret korrekt til mobil, og shop-items blev lagt ind som prefabs med Vertical Layout Group og Content Size Fitter, 
                  så visningen automatisk tilpasser sig forskellige skærmstørrelser.
                </p>

                <h3>Integration med ARFaceList</h3>
                <p>
                  Som en del af shop-funktionaliteten blev der arbejdet på at integrere købte AR-face-prefabs direkte i en ARFaceList, som bruges af AR-systemet i Skattekammer-scenen. 
                  Løsningen gjorde det muligt for spilleren at købe kosmetiske ansigtsgenstande (f.eks. masker), som derefter blev tilføjet automatisk til en liste (ScriptableObject). 
                  Denne liste blev brugt af FacePrefabSelector i AR-scenen til at vise og skifte mellem de købte ansigter. Shoppen blev dermed direkte koblet til AR-oplevelsen, og implementeringen understøttede dynamisk opbygning uden hårdkodning.
                </p>

                <p>
                    Selvom løsningen teknisk fungerede og opfyldte kravene, blev den ikke et elementært delelement i det endelige projekt. 
                    Undervejs i forløbet blev der identificeret en anden metode, som bedre matchede projektets behov og mål – både med hensyn til performance, fleksibilitet og brugeroplevelse. 
                    Derfor blev metoden fravalgt til fordel for en mere effektiv tilgang, men arbejdet med denne del har givet vigtig indsigt i integration mellem shop-system og runtime-data i Unity.
                </p>

                <h3>Udvikling og Justering af AR-Produkter til Virtuel Butik</h3>
                <p>
                  Efter afslutningen af den indledende udvikling af butikken blev fokus rettet mod implementeringen af de produkter,
                  som brugerne kunne købe og interagere med. Den oprindelige intention var at benytte Full Body Tracking til at skabe virtuelle "kostumer",
                  som brugerne kunne iføre sig og tage billeder af i augmented reality (AR).
                  Efter adskillige timers arbejde viste det sig dog,
                  at Unitys dokumentation - i det med småt - angav,
                  at fuld kropssporing udelukkende understøttes på iOS-enheder.
                </p>

                <p>
                  Da projektets målplatform udelukkende anvender Samsung-enheder og gør brug af Google ARCore,
                  var denne funktionalitet desværre ikke anvendelig.
                  Projektgruppen måtte derfor revurdere strategien og vendte tilbage til tegnebrættet.
                  Det blev besluttet at anvende Face Tracking som alternativ.
                  Denne tilgang tillod stadig brugeren at tage billeder af sig selv i AR,
                  hvilket stemte overens med kravspecifikationen, hvor metoden til at tage billedet ikke var nærmere defineret.
                </p>

                <p>
                  For at påbegynde implementeringen af Face Tracking blev Unitys Learning Path for teknologien gennemgået.
                  Herefter blev der udviklet en klasse til håndtering af ansigtsfiltre. Denne klasse gjorde det muligt at tilføje og bladre mellem forskellige filtre.
                  For at gøre systemet mere skalerbart og integrerbart med butikken,
                  blev filtrene struktureret som ScriptableObjects, der indeholder en liste over tilgængelige filtre.
                  En metode til dynamisk at tilføje nye filtre blev tilføjet, hvilket gør det muligt at knytte købte varer til filtrene,
                  således at et filter bliver tilgængeligt for brugeren efter køb.
                </p>
                  <img src="Images/ARFace.png" alt="DevArt" class="image">
                <p>
                  Efterfølgende blev der udviklet en funktionalitet til at tage billeder og gemme dem i brugerens kamerarulle.
                  Et tidligt teknisk problem bestod i, at UI-elementerne, som anvendes til at tage billeder,
                  fortsatte med at være synlige på det færdige billede. Dette blev løst ved at konvertere fotofunktionen til en IEnumerator-metode,
                  som sikrer sekventiel udførelse. Inden selve billedet tages, sættes UI-elementernes alfaværdi til 0 (gennemsigtige),
                  og efter billedet er gemt, sættes alfaværdien tilbage til 255 (fuldt synlig).
                  Billedet gemmes via en platformsspecifik filsti tilpasset Android/Samsung-enheder,
                  og brugeren modtager samtidig en Toast-meddelelse med bekræftelse af, at billedet er gemt.
                </p>

                <p>
                  Afslutningsvis blev AndroidManifest.xml opdateret,
                  så applikationen eksplicit anmoder om tilladelse til at benytte kameraet -
                  analogt med hvordan tilladelser til lokationstracking håndteres.
                  Dette skridt er taget for at sikre overholdelse af gældende lovgivning vedrørende brugen af kamera og persondata.
                </p>

                <h3>Implementering af tværgående funktionalitet mellem scener: Butik og AR-ansigtsfiltre</h3>

                <p>I dette sprint blev der fokuseret på at udvikle funktionalitet, der forbinder eksisterende systemer på tværs af scener,
                   nærmere bestemt interaktionen mellem butiksscenen og "skattekammeret",
                   hvor brugeren har mulighed for at benytte ansigtsfiltre i et AR-miljø.
                   Formålet var at gøre det muligt for brugeren at købe ansigtsfiltre i butikken og efterfølgende anvende disse i skattekammeret til at tage billeder.</p>

                <p>Implementeringen blev realiseret gennem en metode, der først validerer,
                  om brugeren har tilstrækkelige midler i form af "guld" (håndteret via et eksisterende Gold-script) til at foretage et køb.
                  Herefter undersøges det, om den valgte vare er gyldig. Hvis begge betingelser er opfyldt,
                  tilføjes det pågældende ansigtsfilter (repræsenteret som et prefab) til en liste over tilgængelige filtre for brugeren.
                  Denne funktionalitet blev realiseret ved hjælp af scriptet ARFaceFilters, som håndterer brugerens samling af filtre.</p>
                  
                <p>et væsentligt aspekt af denne opgave var at sikre persistens, så købte varer forbliver tilgængelige på tværs af sessioner.
                  Da Unitys PlayerPrefs og JSON-format ikke understøtter direkte lagring af GameObject-referencer, blev der i stedet valgt en løsning,
                  hvor navnene på de købte filtre gemmes som strings i JSON-format. Disse gemmes i PlayerPrefs,
                  og ved genstart af applikationen indlæses navnene og matches mod en statisk liste over alle tilgængelige ansigtsfiltre i systemet.
                  Ved et match rekonstrueres brugerens samling, hvilket sikrer, at købte varer forbliver tilgængelige.</p>

                <p>Når et køb er gennemført, fratrækkes den relevante mængde guld fra brugerens saldo.
                   Det købte produkt fjernes derefter fra butikkens udbud, og butikken opdateres, så kun ikke-købte varer vises.
                   Købsstatussen gemmes ligeledes i PlayerPrefs, hvilket forhindrer brugeren i at købe den samme vare mere end én gang.</p>

                <p>Denne løsning understøtter således både funktionel integration mellem separate scener og sikrer datavedholdelse for brugerens købte indhold,
                   hvilket er centralt for en konsistent brugeroplevelse.</p>

                <h3>Implementering af miniGame System</h3>

                <p>I dette sprint blev det besluttet at fokusere på at færdiggøre selve kernen af spiloplevelsen - det,
                   vi betegner som "skattejagten". Den primære målsætning var at etablere funktionaliteten omkring interaktionen med en kongekrone,
                   som fungerer som udgangspunkt for en række minispil.
                   Når spilleren interagerer med kronen, skal et tilfældigt minispil aktiveres, hvilket,
                   ved succesfuld gennemførelse, belønner spilleren med en vis mængde guld.</p>

                <p>For at sikre systemets fleksibilitet og fremtidige udvidelsesmuligheder
                   blev der valgt en arkitektonisk løsning baseret på Strategy Pattern.
                   Denne tilgang muliggør nem integration af nye minispil uden behov for at ændre den eksisterende logik.
                   Et centralt element i implementeringen var en MiniGameManager, som automatisk identificerer og registrerer alle spil,
                   der implementerer det definerede IMiniGame interface. Ved aktivering udvælges et af disse spil tilfældigt.</p>

                <p>Eftersom alle spilkomponenter er afhængige af Unitys MonoBehaviour,
                   blev der oprettet en abstrakt klasse, MiniGameBase,
                   som fungerer som bindeled mellem IMiniGame og de konkrete spiltyper.
                   Denne løsning muliggør, at minispil både kan nedarve fra MonoBehaviour og samtidig overholde IMiniGame interfacet.</p>

                <h3>Valg og Implementering af Minispil</h3>

                <p>Til at begynde med blev der udviklet tre minispil,
                   som alle tager udgangspunkt i kendte spilmekanikker for at sikre høj brugerforståelse og lav indlæringskurve.
                  Disse er:</p>

                <ul>
                  <li><b>KingClicker:</b> inspireret  af "Cookie Clicker</li>
                  <li><b>FalppyKing:</b> inspireret af "flappy Bird</li>
                  <li><b>CatchKing:</b> inspireret af klassiske "dropper"-spil </li>
                </ul>

                <img src="Images/Flappyking.png" alt="DevArt" class="image">
                <p>Alle minispil blev implementeret som UI-elementer,
                   hvilket reducerede den tekniske kompleksitet,
                   men medførte visse begrænsninger i brugen af fysiske komponenter såsom colliders og transforms.</p>

                <h4>KingClicker</h4>
                <p>Dette var det første spil, der blev implementeret.
                   Spillet går ud på, at spilleren optjener guld ved at klikke gentagne gange på en kongekrone inden for en begrænset tidsramme.
                   Tidens udløb vises via en grafisk UI-slider. Spillet er simpelt i sin mekanik,
                   men tjener som en effektiv introduktion til minispilssystemet.</p>

                  <h4>FlappyKing</h4>
                  <p>Dette spil er en UI-baseret version af "Flappy Bird",
                     hvor spilleren styrer en faldende kongekrone ved at trykke på skærmen for at få den til at stige.
                     Målet er at navigere gennem rør og optjene guld. 
                     En teknisk udfordring i dette spil var,
                     at UI-elementer i Unity ikke understøtter klassiske fysiske komponenter som colliders.
                     Derfor blev logikken implementeret ved hjælp af RectTransform overlap-tjek frem for fysiske kollisioner.
                     På trods af dette lykkedes det at skabe en oplevelse, der minder om originalen.</p>

                  <h4>CatchKing</h4>
                  <p>Det sidste spil, der blev udviklet i denne sprint, var CatchKing.
                     Her falder både kroner og bomber ned over skærmen,
                     og spilleren skal forsøge at samle så mange kroner som muligt uden at røre bomberne.
                     Spillet benytter sig af en Object Pooling-mekanisme til at håndtere de faldende elementer effektivt.
                     En udfordring her var at sikre korrekt interaktion mellem objekterne i puljen og brugerens input,
                     hvilket dog blev løst tilfredsstillende.</p>

                  <h3>Integration og Visuelle Forbedringer</h3>

                  <p>Efter implementeringen af de individuelle spil blev MiniGameManager integreret med kongekronen i spilverdenen.
                     Det betyder, at hver gang en krone genereres i spillet,
                     medfølger funktionaliteten til at starte minispil direkte ved interaktion.
                     Derudover blev der udviklet en separat klasse, der håndterer rotationen af kongekronen
                     for at give en animeret og mere iøjnefaldende præsentation, hvilket bidrager til et mere levende og dynamisk visuelt udtryk.</p>

                  <p>Det samlede resultat af sprintet er et fleksibelt og skalerbart minispilssystem,
                     der gør det muligt for udviklere nemt at tilføje nye spil blot ved at implementere
                     det eksisterende interface og arve fra den abstrakte MiniGameBase klasse.
                     Denne arkitektur sikrer en nem vedligeholdelse og udvidelse af systemet i fremtidige iterationer
                     og understøtter videreudviklingen af den samlede spiloplevelse.</p>

                    <h3>Implementering af point-system (ScoreTracker)</h3>

                    <p> 
                        For at udvide shop-systemet og øge spillerens motivation blev et nyt pointsystem implementeret sideløbende med det eksisterende guld. 
                        Ideen bag systemet var, at spilleren optjener point hver gang der optjenes guld, men uden at miste disse point ved køb. 
                        På den måde fungerer point som en form for "samlet optjent guld", som giver et billede af den langsigtede progression.
                    </p>

                    <p>
                        Systemet blev designet ud fra SOLID-principper – særligt Single Responsibility og Dependency Inversion. 
                        Logikken blev derfor delt op i interfaces: IAddScore og IGetScore, og selve tracking-klassen ScoreTrackerSeparated blev isoleret fra UI. 
                        UI-delen blev håndteret af en separat ScoreTrackerPresenter, som kommunikerer via SetPresenter(...)-metoden. 
                        Denne opdeling gør systemet lettere at vedligeholde og udvide, f.eks. hvis man senere vil vise point på flere UI-elementer eller skifte lagringsmetode.
                    </p>

                    <h3>Leaderboard og integration med point-systemet</h3>

                    <p>
                        Et leaderboard blev tilføjet som en afsluttende del af point-systemet, så spilleren kan sammenligne sin score med andre. 
                        Dette system blev bygget ud fra en Unity-pakke leveret af Pelle, som indeholdt scripts som SubmitScorePanel, ScoreView, ScoreList, LeaderBoard, HighscoreData og AddScore.
                    </p>

                    <p>
                        Leaderboardet blev integreret med det eksisterende ScoreTrackerSeparated og ScoreTrackerPresenter-system ved at ændre SubmitScorePanel-scriptet. 
                        I stedet for manuelt indtastede scores hentes spillerens faktiske score nu automatisk og vises i et låst felt. 
                        Dette bidrager til en mere brugervenlig oplevelse og forbedrer dataintegriteten. Til integrationen blev der benyttet en API Key og et Game ID udleveret af Pelle, som konfigureres i HighscoreData for at muliggøre ekstern lagring og visning af highscores.
                    </p>

                    <b>API Key:</b>
                    <p>
                        6d5ad9adc2e3ecc525b288b9af5719f0b6b082352715ab8f8efa03daa012e6c3
                    </p>

                    <b>ID:</b>
                    <p>
                        SEP2-AR-RRI
                    </p>

                    <p>
                        UI'et fra pakken blev også tilpasset, så det visuelt passede med resten af projektet og fungerede på mobil. 
                        Selvom vi oprindeligt vurderede, at opgaven ville tage omkring 100 story points, viste det sig, at den reelle arbejdsbyrde var tættere på 16 story points, da koden i høj grad allerede var givet og kun krævede integration og justeringer.
                    </p>



              </div>
              <div class="SideNummer"></div>
        </p>
        
        <br>

        

        <h2 id="refleksioner">5. Personlige refleksioner</h2>
        <p>
          <h3>Nikolaj</h3>
          jeg syntes personligt jeg har kunne bidrage med en del til projektet, da jeg har hhaft stor 
          drivkraft og motivation til at få det til at lykkedes. blandt andet føler jeg at jeg har været
          medvirkende til at skubbe projekt meget frem løbende og sørget for at vi kom videre i proccessen.
          der har dog være både fordel og ulemper ved dette, blandt andet ville jeg gerne havde haft at
          jeg fra start af havde lagt noget mere fokus på arkitekturen i projeket og sørget for at det jeg
          lavede tidligt i forløbet var SOLID, da det først er noget jeg begyndte af havde en bedre forståelse 
          for senere i forløbet, hvilket betyd at ting jeg lavede tidligt i forløbet skulle laves om. 
          der er mine "røde" personligheds træk virkligt komme til udtryk, ydeligere har der også været flere 
          fordel og udlember i forbindelse med at jeg har den "røde" personlighed, da vi løbende har valgt
          at rotere mellem de forskellige roller i gruppen, hvilket har til tidere haft en negativ indflydelse
          på mig, da jeg ofte har siddet med en plan for hvordan noget skulle være i mit hovede, men så har en
          projekt ovner vlagt en anden løsning, så der har jeg skulle tilpasse mig til det, hvilket har været
          en udfordring men syntes jeg har været god til at give plads i gruppen og tilpasse mig til det. således
          at jeg ikke har brudt for meget igenem og taget styringen med det helle, dette er dog noget jeg har
          skulle aflære mig slev, da det ligger dybt i mig, kva den kultur i forsvaret jeg kommer fra, hvor
          jeg kva mit tildligere job som sergent har været vant til at tage styringen og have det overordnede ansvar.
          dog syntes jeg at gruppen har været gode til at sammearbejde og jeg har ikke en føglese af at 
          der har været noget hvor jeg har taget styringen over hovedet på andre.
          <p>
          igenem forløbet har jeg fået en klart bedre forstålese for værdigen af både at have en god arkitektur
          og brugen af design patterns, da det har gjort at det krævede markant mindre ændringer i det kode jeg
          har lavet efterfølgende, samt det har været nemmer for gruppen både at kunne forstå og tilslutte deres
          egen kode mere til det jeg har lavet. 
          </p>
          <p>
          særligt i den sidste del af forløbet har jeg kunne mærke mine røde personlighedstræk, da det er svært
          for mig at stå inde for et projekt som ikke er "færdigt" så det har medføret mange overtimeres arbejde
          for at få nået så meget af projket som muligt. specielt i forbindelse med at i vores sidste sprint 
          oplevede vi at en meget essentielt del af vores system ikke virkede, der var det specelt hårdt for
          mig at være i, da det var en del af projket som jeg kun har været delvist involveret i og derfor
          ikke har kunne være en drivende kraft i at få problemmerne til at blive løst, det gav mig en følelse
          af hjælpeløshed, da jeg kun har kunne bidrag med enkelte ting til løsningen af problemet. og har 
          måtte stole på at de vedrørende i gruppen har kunne været i stand til at løse det. dette har dog
          betydet at jeg har taget meget ansvar i at få udarbejdet en masse andre dele af projketet, i mellem
          tiden.
          </p>
          <p>
           generalt syntes jeg at vi har haft en god dynamik i gruppen og at vi har været gode til at
          samarbejde og hjælpe hinanden, til at komme så langt i projektet som vi er resulteret i at være kommet
          </p>

          <h3>Patrick</h3>
          <p>
              Under arbejdet med projektet oplevede jeg, hvor vigtigt det er at udvikle systemer, der er fleksible og lette at vedligeholde. 
              Jeg havde tidligere en tendens til at hardkode funktioner, som fx sceneskift, men under dette projekt blev det meget tydeligt for mig, hvor hurtigt det bliver uoverskueligt i større applikationer. 
              Jeg lærte, at det er langt mere hensigtsmæssigt at arbejde med mere dynamiske løsninger, fx via event-systemer eller konfigurerbare objekter. 
              Det er noget, jeg helt klart vil implementere tidligere i fremtidige projekter.
          </p>

          <p>
              Jeg fandt også ud af, hvor værdifuldt det er at bruge Unitys UI-system med Scroll View, Vertical Layout Group og Content Size Fitter. 
              Det hjalp mig med at lave en brugerflade, der tilpasser sig forskellige skærmstørrelser – især med mobiltelefoner i tankerne. 
              Det gav mig konkret erfaring med, hvordan man kan tænke responsivt design ind fra starten, og jeg blev bedre til at arbejde struktureret med prefabs og editorbaseret konfiguration.
          </p>

          <p>
              Under arbejdet med at forbinde shop-funktionen med AR-face-funktionaliteten lærte jeg meget om, hvordan man kan arbejder med ScriptableObjects og dynamisk datahåndtering i Unity. 
              Det var spændende at prøve på at udvikle en løsning, hvor købte items direkte kunne integreres i AR-oplevelsen i en anden scene, uden at skulle ændre eksisterende scripts. 
              Men på trods af at løsningen teknisk virkede, valgte vi i sidste ende en alternativ metode, der passede bedre til projektets mål. Det var en værdifuld proces, da jeg fik praktisk erfaring med designvalg og lærte at tage højde for både funktionalitet og brugervenlighed i en helhedsorienteret løsning.
          </p>

          <p>
              Implementeringen af pointsystemet gav mig værdifuld erfaring med at tænke i mere strukturerede og skalerbare løsninger. 
              Ved at benytte interfaces og en adskilt Presenter-klasse lærte jeg, hvordan man kan holde sin logik ren og adskilt fra visningen. 
              Det føltes som et skridt i retning af mere professionel softwarearkitektur. Jeg blev også opmærksom på, at selv små systemer – som f.eks. et simpelt scoremodul – kan drage fordel af SOLID-principper, især hvis projektet vokser. 
              Jeg vil tage denne læring med videre til fremtidige projekter, hvor det at strukturere kode tidligt kan spare meget arbejde senere.
          </p>

          <p>
              Arbejdet med leaderboardet var en god øvelse i at integrere andres kode i vores projekt. 
              Det krævede forståelse af, hvordan de eksisterende scripts fungerede, samt hvordan jeg kunne koble dem sammen med mit eget point-system. 
              Det gav mig også en bedre forståelse for, hvordan man skriver kode, der er let at integrere – f.eks. ved brug af interfaces som IGetScore.
          </p>

          <p>
              Overordnet føler jeg, at jeg har udviklet mig meget i forhold til at tænke mere professionelt og langsigtet i min tilgang til både UI-design og opbygningen af systemer. 
              Jeg har fået større forståelse for vigtigheden af at adskille ansvar i koden, arbejde med genanvendelige komponenter og tænke i skalerbare løsninger fra starten. 
              Jeg har lært af mine fejl og set konkret, hvordan små valg tidligt i processen kan gøre stor forskel senere. 
              Det har givet mig både selvtillid og motivation til at arbejde endnu mere målrettet med at skrive robust, fleksibel og vedligeholdelsesvenlig kode i fremtidige projekter.
          </p>
                  
        </p>
        <div class="SideNummer"></div>
        
        <h2 id="vejledning">6. Refleksioner over vejledning</h2>
        <p>[Indsæt din tekst her]</p>
        <div class="SideNummer"></div>

        <h2 id="Konklusion">7. Konklusion</h2>
        <p>[Indsæt din tekst her]</p>
        <div class="SideNummer"></div>
        
        <h2 id="referencer">8. Referencer</h2>
        <p>[Indsæt din tekst her]</p>
    </div>

    <div class="footer"></div>

    <script src="Scirpt.js"></script>
</body>
</html>
